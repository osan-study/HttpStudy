## 캐시
> 캐시는 자주 쓰이는 문서의 사본을 자동으로 보관하는 장치로 요청을 받았을 때 캐시된 사본이 존재하면 캐시로부터 문서를 제공합니다.

### 불필요한 데이터 전송
복수의 클라이언트가 특정 페이지에 접속 할 때 같은 문서를 서버에서 각각 연산하여 전달하지 않고 캐시 서버에서 연산 없이 바로 전달 가능합니다.

### 대역폭 병목
서버와의 네트워크보다 로컬 네트워크의 대역폭이 일반적으로 높으므로 로컬 네트워크 또는 대역폭이 넓은 경로에 있는 캐시 서버로부터 데이터를 받아 올 때 병목을 줄일 수 있습니다.

### 갑작스런 요청 쇄도<sup>Flash Crowds</sup>
많은 사람이 동시에 웹 문서에 접근 할 경우 원천 서버의 직접 장애를 막을 수 있습니다.

### 거리로 인한 지연
클라이언트와 서버와의 물리적인 거리가 매우 클 경우 빛의 속도로 신호가 이동하더라도 유의미한 지연이 발생될 수 있습니다.

<img width="485" alt="image" src="https://github.com/osan-study/HttpStudy/assets/27123002/9fa73af9-14da-439c-930b-04a16ba34da1">

### 적중과 부적중
캐시에 요청이 도착했을 때 요청에 대응하는 사본이 있다면 캐시에서 전달(hit), 사본이 없다면 원 서버로 전달(miss)됩니다.

<img width="480" alt="image" src="https://github.com/osan-study/HttpStudy/assets/27123002/887abc0d-f67b-496f-b4a9-7edc0dfcb9d9">

#### 재검사
재검사가 필요할 때 원천 서버에 작은 재검사 요청을 보내고 콘텐츠가 변경되지 않았으면 서버는 304 응답을 보냅니다. 사본이 유효함을 확인했으므로 사본에 신선하다고 표시한 뒤 클라이언트에게 제공합니다. 서버로부터 리소스를 전달 할 필요가 없으므로 비교적 빠릅니다.

[If-Modified-Since](https://developer.mozilla.org/ko/docs/Web/HTTP/Headers/If-Modified-Since) 헤더를 추가하여 요청하면 지정된 날짜 이후 수정된 경우에 요청된 리소스를 전달하고 수정되지 않았으면 리소스 없이 304 응답을 보냅니다. 만약 리소스가 삭제되었다면 404를 돌려보내고 캐시는 사본을 삭제합니다.

<img width="483" alt="image" src="https://github.com/osan-study/HttpStudy/assets/27123002/c1fd558e-a9c1-4fde-bb46-0523f179a250">

#### 적중률
받은 요청 대비 적중한 요청의 비율으로 40% 수준이면 웹 캐시로 괜찮은 편이며 바이트 단위로 적중률을 관리 하는 경우도 있습니다.

#### 적중과 부적중의 구별
HTTP는 응답이 캐시 적중이었는지 말해주는 방법을 제공하지 않으므로? Date 헤더를 이용해 응답이 캐시된 것인지 확인합니다.

### 캐시 토폴로지
캐시는 개인 전용 캐시로 할당 될 수 있으며 웹브라우저에 내장되어 있습니다. 사용자 집단에게 공용으로 제공 할 때는 서버에서 공용 캐시로 리소스를 한번 가져오고 사용자들은 제공된 캐시에서 문서에 각각 접근하여 가져갑니다.

#### 프락시 캐시 계층
클라이언트 주위에는 저렴한 캐시를 사용하고 계층 상단에는 고정능의 캐시를 사용하여 더 많은 문서와 많은 트래픽을 감당할 수 있도록 합니다.

몇몇 네트워크 아키텍처에서는 복잡한 캐시망을 만들어 서로 커뮤니케이션하고 상황에 따라 다음과 같이 동적으로 캐시를 전달합니다.
- URL 기반으로 캐시와 원 서버 중 하나를 동적으로 선택한다.
- URL 기반으로 특정 캐시를 동적으로 선택한다.
- 캐시에게 가기 전에 로컬에서 사본을 찾아본다.
- 캐시들이 부분적으로 접근 할 수 있지만 트랜짓은 할 수 없게 한다.

### 캐시 처리 단계
1. 네트워크로부터 도착한 요청 메시지를 읽는다.
2. 메시지를 파싱하여 URL과 헤더들을 추출한다.
3. 로컬 복사본이 있는지 검색하고 사본이 없으면 리소스를 받아온다.
4. 사본이 신선한지 검사하고 신선하지 않으면 서버에게 요청한다.
5. 헤더를 적절히 번역하고 캐시 정보(Cache-Control, Age, Expires, Via header)를 삽입하며 캐시된 본문으로 응답 메시지를 만든다.
6. 응답을 클라이언트에게 돌려준다.
7. 선택적으로 트랜색션에 대해 로그를 남긴다.

### 사본을 신선하게 유지하기

#### 문서 만료
특별한 헤더를 이용해서 각 문서에 유효기간을 붙인다.
- Cache-Control: max-age (문서의 최대 나이를 정의하며 문서가 생성된 이후 사용 가능한 기간을 정의한다.)
- Expires: 절대 유효기한으로 정해진 날짜까지 유효하다.

#### 조건부 메서드와의 재검사
조건부 GET 요청으로 조건에 해당 될 때 캐시 재 검사를 진행 할 수 있다.
If-Modified-Since: Last-Modified 헤더와 비교하여 주어진 날짜보다 Last-Modified 날짜가 크다면 평범하게 요청을 처리하고 아니라면 304를 리턴한다.

<img width="479" alt="image" src="https://github.com/osan-study/HttpStudy/assets/27123002/60e92073-bddb-4f75-a3c6-6ae5f3c09d96">

If-None-Match
  - tag를 제공하고 원 서버에게 tag가 바뀌었을 경우에 새 객체를 달라고 요청한다.
  - 여러개의 사본을 가지고 있는 경우 여러개의 tag를 포함시킬 수 있다.

<img width="482" alt="image" src="https://github.com/osan-study/HttpStudy/assets/27123002/45f5488f-7e93-4548-acc3-ae25e49cb131">

#### 약한 검사기와 강한 검사기
약한 검사기는 어느정도 콘텐츠 변경을 허용하지만 강한 검사기는 콘텐츠가 조금이라도 바뀔 때마다 사본을 무효화 시킨다.

‘W/‘ 접두사를 이용해 약한 검사기를 구분한다.

#### 캐시 제어
- no-store : 캐시가 응답의 사본을 만드는것을 금지한다. 민감한 정보가 포함되어 있을 때 주로 사용한다.
- no-cache : 로컬 캐시 저장소에 응답을 저장 할 수는 있지만 서버와 재 검사 이후에 클라이언트로 제공된다.
- Max-Age : 문서가 서버로 부터 응답된 시간부터 설정된 기간까지는 캐시를 리턴한다.
- Expires : 실제 만료 날짜를 명시해서 해당 날짜 이후로 캐시가 만료되도록 한다. 0으로 설정하면 항상 만료되지만 문법적으로 적절하지 않다.
- Must-Revalidate : 무조건 원 서버와의 재검사 후 제공하고 원 서버가 사용 불가능하다면 504를 리턴한다.
- 휴리스틱 만료
  - max-age 헤더나 Expires 헤더가 없다면 경험적인 방법으로 최대 나이를 계산한다.
  - 일반적으로 유지기간에 상한을 설정하며 보통 1주일, 보수적인 사이트는 하루로 설정한다.
- 클라이언트 신선도 제약 : 웹브라우저는 신선하지 않은 콘텐츠를 강제로 갱신시켜 주는 리프레시 버튼을 가지고 있으며 Cache-control 요청 헤더가 추가된 GET 요청을 발생시킨다.

<img width="343" alt="image" src="https://github.com/osan-study/HttpStudy/assets/27123002/714ba177-47fd-4f58-b2ea-9d70a005b1f7">

### 캐시 제어 설정

> 웹 서버들은 캐시 제어와 문료 HTTP 헤더들을 설정하는 서로 다른 메커니즘을 사용한다.

#### NGINX Cache 설정

캐싱을 활성화 하려면 proxy_cache_path 및 proxy_cache 지시문이 필요하다.
```
proxy_cache_path /path/to/cache levels=1:2 keys_zone=my_cache:10m max_size=10g 
                 inactive=60m use_temp_path=off;
server {
    # ...
    location / {
        proxy_cache my_cache;
        proxy_cache_revalidate on;
        proxy_cache_min_uses 3;
        proxy_cache_use_stale error timeout updating http_500 http_502
                              http_503 http_504;
        proxy_cache_background_update on;
        proxy_cache_lock on;
        proxy_pass http://my_upstream;
    }
}
```

proxy_cache_path 지시문의 매개변수는 다음 설정을 의미합니다.
- `/path/to/cache/` : 캐시의 로컬 디스크 디렉토리 경로를 지정한다.
- `levels`: /path/to/cache/ 아래에 2단계 디렉터리 계층 구조를 설정한다. 단일 디렉터리에 많은 수의 파일이 있으면 파일 액세스 속도가 느려질 수 있으므로 대부분 2단계 디렉터리 계층 구조를 사용하는 것이 좋다.
- `keys_zone`은 캐시 키 및 사용 타이머와 같은 메타데이터를 저장하기 위한 공유 메모리 영역을 설정하며 메모리에 키 복사본이 있으면 메모리에서 바로 요청이 HIT인지 MISS인지 빠르게 결정할 수 있어 검사 속도가 크게 빨라진다.
- `max_size`는 캐시 크기의 상한을 설정한다. 값을 지정하지 않으면 캐시가 사용 가능한 모든 디스크 공간을 사용하도록 확장되며 캐시 크기가 제한에 도달하면 캐시 관리자라는 프로세스가 캐시 크기를 제한 아래로 되돌리기 위해 가장 최근에 사용된 파일을 제거한다.
- `inactive`는 캐시에서 지정된 기간 동안 액세스되지 않은 항목을 삭제합니다. 만료된 콘텐츠는 자동으로 삭제되지 않으므로 유의해야 합니다. 이 기능을 사용하면 캐시 용량을 효율적으로 유지할 수 있습니다.
- NGINX는 먼저 캐시로 향하는 파일을 임시 저장 영역에 기록하고 `use_temp_path=off` 지시문은 NGINX에 해당 파일이 캐시될 동일한 디렉터리에 쓰도록 지시합니다. 파일 시스템 간에 불필요한 데이터 복사를 방지하려면 이 매개변수를 off로 설정하는 것이 좋습니다. use_temp_path는 NGINX 버전 1.7.10 및 NGINX Plus R6에서 도입되었습니다.
- `proxy_cache` 지시문은 상위 위치 블록의 URL(예: /)과 일치하는 모든 콘텐츠의 캐싱을 활성화합니다.
- `proxy_cache_revalidate`는 조건부 GET 요청을 사용하여 원본 서버에서 콘텐츠를 새로 고칩니다. 이는 캐시된 콘텐츠가 만료되었거나 변경된 경우 유용합니다.
- `proxy_cache_min_uses`는 클라이언트가 항목을 요청해야 하는 횟수를 설정합니다. 이렇게 하면 캐시된 콘텐츠가 실제로 사용되지 않을 때 캐시에서 삭제됩니다.
- `proxy_cache_use_stale`은 오래된 콘텐츠를 전달하도록 지시합니다. 이는 오래된 콘텐츠를 전달하면서 원본 서버에서 새로 고침을 수행하는 동안 클라이언트의 대기 시간을 줄일 수 있습니다.
- `proxy_cache_lock`은 여러 클라이언트가 동시에 요청할 때 첫 번째 요청만 Origin 서버를 통과하도록 합니다. 이렇게 함으로써 불필요한 중복 요청을 방지하고 성능을 향상시킬 수 있습니다.

[출처 : NGINX STORE - NGINX Cache 시스템 이해하기](https://nginxstore.com/blog/nginx/nginx-%EB%B0%8F-nginx-plus%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-caching/)
