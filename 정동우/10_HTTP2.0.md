# HTTP/2.0

## 10.1 HTTP/2.0의 등장 배경

HTTP/1.1은 커넥션 하나를 통해 요청을 보내고 응답 하나를 받는 교환 방식으로 응답을 받아야만 다음 요청을 보낼 수 있기 때문에 회신 지연이 생겼으며 문제 해결을 위해 병령 커넥션이나 파이프라인 커넥션이 도입되었으나 근본 해결이 되지 않아 새로운 프로토콜이 필요하게 되었다.

HTTP/2.0 Timeline

- 2009년 구글에서 HTTP에 속도를 개선하기 위한 기능을 추가한 SPDY 프로토콜을 발표
- 2012년 10월 3일 HTTP 워킹 그룹에서 SPDY를 기반으로 HTTP/2.0을 개발하기로 결정
- 2015년 5월 HTTP/2.0이 공식적으로 승인

HTTP/2.0의 주요 특징

- 헤더를 압축하여 대역폭을 절약하고 전송된 데이터의 중복과 오버헤드 제거
- 하나의 TCP 커넥션에 여러 요청을 동시에 보내서 회전 지연을 줄임
- 서버가 서버 푸시라는 메커니즘을 이용해 클라이언트 캐시에 데이터를 저장 가능

## 10.2 개요

HTTP/2.0은 서버와 클라이언트 사이의 TCP 커넥션 위에서 동작하며 클라이언트가 커넥션을 초기화 한다.

하나의 커넥션에서 여러개의 스트림이 동시에 들어갈 수 있고, 스트림에 요청/응답이 압축된 헤더와 같이 담기므로 다수의 요청, 응답을 동시에 처리 할 수 있다.

서버 푸시를 적용하여 클라이언트가 요청하지 않았더라도 필요하다고 판단되는 리소스를 능동적으로 보낼 수 있다.

## 10.3 HTTP/1.1과의 차이점

### 10.3.1 프레임

HTTP/1.1에서 응답과 요청 메세지는 이진 형식이 아닌 일반 텍스트를 사용한 데이터의 구조화된 블록이었으나 HTTP/2.0에서는 모든 메시지가 프레임에 담겨 전송된다.

    +-----------------------------------------------+
    |                 Length (24)                   |
    +---------------+---------------+---------------+
    |   Type (8)    |   Flags (8)   |
    +-+-------------+---------------+-------------------------------+
    |R|                 Stream Identifier (31)                      |
    +=+=============================================================+
    |                   Frame Payload (0...)                      ...
    +---------------------------------------------------------------+

프레임 헤더의 필드는 다음과 같다.

- Length : 페이로드의 길이를 나타내는 24비트 무부호 정수로 `SETTINGS_MAX_FRAME_SIZE`에 더 큰 값을 설정하지 않는 이상 2<sup>14</sup>(16,384)보다 작아야 한다.
- Type : 8비트의 타입 정보로 미리 정의된 10가지 프레임 타입에 해당하지 않으면 무시해야 한다.
- Flags : 지정된 프레임 유형에 맞는 의미가 할당되며 유형에 정의된 의미가 없는 플래그는 무시하고 미설정(0x0)으로 남겨둬야 한다.
- R : 예약된 1비트 필드로 전송시에는 0x0으로 유지되어야 하고 수신 시에는 무시되어야 한다.
- Stream Identifier : 31비트 무부호 정수로 프레임이 속한 스트림을 식별한다.

### 10.3.2 스트림과 멀티플렉싱

스트림은 HTTP/2.0 커넥션으로 클라이언트와 서버 사이에서 교환되는 프레임들의 독립된 양방향 시퀀스이다.

HTTP/1.0에서는 하나의 커넥션에 하나의 요청과 응답이 오가지만 HTTP/2.0에서는 하나의 커넥션에 여러개의 스트림이 동시에 열릴 수 있다.

또한 스트림은 우선순위를 가질 수 있으며 사용자가 특정 웹 페이지를 보려고 할 때 네트워크 대역폭이 충분하지 않을 경우 중요한 리소스(이미지보다 HTML)을 요청하는 스트림에게 높은 우선순위를 부여할 수 있다.

스트림은 31비트의 무부호 정수 식별자를 가지며 클라이언트가 요청을 보내면 스트림 식별자가 홀수로 할당되고 서버가 응답을 보내면 스트림 식별자가 짝수로 할당된다. 규칙을 어길 경우 `PROTOCOL_ERROR` 오류를 반환한다.

서버와 클라이언트는 협상 없이 스트림을 만들 수 있다.

한번 사용한 스트림 식별자는 다시 사용 할 수 없고 식별자가 고갈되었을 경우 커넥션을 다시 맺으면 된다.

### 10.3.3 헤더 압축

`HTTP/1.1`에서 헤더는 압축 없이 그대로 전송되었는데 과거에는 웹페이지 방문 시 요청이 많지 않았기 때문에 헤더의 크기가 큰 것이 문제가 되지 않았지만 요즘은 웹페이지 방문 시 수십에서 많으면 수백번의 요청을 보내기 때문에 회전 지연과 대역폭 낭비가 문제가 되었다.

`HTTP/2.0`에서는 헤더를 압축하여 전송하며 헤더는 `HPACK` 명세에 정의된 압축 방법으로 압축하고 `헤더 블록 조각`으로 전송되고 받는 쪽에서 조각을 모아서 압축을 해제한다.

`HPACK`은 헤더를 압축하고 해제 할 때 `압축 콘텍스트`를 사용하므로 오동작 하지 않으려면 `압축 콘텍스트`가 동기화 되어야 한다. `압축 콘텍스트`는 수신한 헤더의 압축을 풀 때 바뀌므로 송신측은 항상 콘텍스트가 변경되었음을 가정한다. 따라서, 헤더를 받은 수신 측은 헤더를 사용하지 않는 경우에도 압축을 해제해야 하고 그렇지 않을 경우 `COMPRESSION_ERROR`와 함께 커넥션을 종료해야 한다.

### 10.3.4 서버 푸시

HTTP/2.0에서는 서버가 하나의 요청에 대해 여러 개의 리소스를 보낼 수 있으며 클라이언트가 필요하다고 판단되는 리소스(HTML 문서에 링크된 CSS, JS, 이미지)를 미리 보낼 수 있다.

리소스를 푸시하려는 서버는 해당 리소스를 클라이언트가 별도로 요청하는 상황을 피하기 위해 PUSH_PROMISE 프레임을 보내서 미리 알려줘야 하고 클라이언트가 해당 프레임을 받으면 스트림은 예약됨 상태가 되는데 클라이언트는 RST_STREAM 프레임을 보내서 푸시를 거부할 수 있고 스트림이 닫히기 전까지 클라이언트는 서버가 푸시하려고 하는 리소스를 요청해서는 안된다.

서버 푸시를 사용 할 때는 아래 사항을 고려해야 한다.

- 서버 푸시를 사용하기로 했더라도 프락시가 서버로부터 받은 추가 리소스를 클라이언트에게 전달하지 않을 수 있으며 추가 리소스를 받지 않았더라도 클라이언트에게 추가 리소스를 전달 할 수도 있다.
- 서버는 오직 안전하고, 캐시 가능하고, 본문을 포함하지 않은 요청에 대해서만 푸시 할 수 있다.
- 푸시할 리소스는 클라이언트가 명시적으로 보낸 요청과 연관되어 있어야 한다.
- 클라이언트는 반드시 서버가 푸시한 리소스를 `동일 출처 정책`에 따라 검사해야 한다.
- 서버 푸시를 끄고 싶다면 `SETTING_ENABLE_PUSH`를 0으로 설정하면 된다.

## 10.4 알려진 보안 이슈

### 10.4.1 중개자 캡슐화 공격

헤더 필드의 이름과 값을 바이너리도 인코딩하므로 헤더 필드로 어떤 문자열이든 사용할 수 있게 하므로 정상적인 HTTP/2.0 요청이 위조된 HTTP/1.1 메시지로 번역될 수 있다.

HTTP/1.1 메시지를 HTTP/2.0 메시지로 번역하는 과정에서는 이 문제가 발생하지 않는다.

### 10.4.2 긴 커넥션 유지로 인한 개인정보 누출 우려

어떤 사용자가 브라우저를 사용할 때 이전에 브라우저를 사용했던 사용자가 무엇을 했는지 알아낼 가능성이 있다.
