# 12 장 기본 인증

- 웹사이트에 있는 개인의 프로필이나 개인이 작성한 문서는 해당 소유자의 동의 없이는 권한이 없는 사용자가 볼 수 없어야 한다.
- 기업에 있는 민감한 전략 문서는 조직 내에서 권한이 없는 임직원이 볼 수 없게 해야한다.
- 웹은 편한 공간이어야 한다.
- 서버가 사용자가 누구인지 식별 할 수 있어야 한다.
    - 서버가 사용자가 누군이지 알면, 그 사용자가 어떤 작업이나 리소스에 접근 할 수 있는지 결정할 수 있다.
    - 인증은 당신이 누구인지 증명하는 것이다. 보통 사용자가 이름과 비밀번호를 입력해서 인증한다.
    - HTTP는 자체적인 인증 관련 기능을 제공한다.

## 12.1 인증

- 인증은 당신이 누구인지 증명하는 것이다.
- 완벽한 인증이란 없다.
    - 비밀번호는 누군가의 추측하거나 엿들을 수 있다.
    - 하지만 당신이 누군이지 판단하는데 도움이 된다.

## 12.1.1 HTTP의 인증요구/응답 프레임워크

- HTTP는 사용자 인증을 하는데 사용하는 자체 인증 요구/응답 프레임워크를 제공한다.
- 웹 애플리케이션이 HTTP 요청 메시지를 받으면, 서버는 요청을 처리하는 대신에 현재 사용자가 누구 인지를 알수 있게 비밀번호 같이 개인 정보를 요구하는 “인증요구” 로 응답할 수 있다.
- 사용자가 다시 요청을 보낼 때는 인증정보(사용자 이름과 비밀번호)를 첨부해야한다.
    - 만약 인증 정보가 맞지 않으면 서버는 클라이언트에 다시 인증 요구를 보내거나 에러를 내보낼 수 있다.

## 12.1.2 인증 프로토콜과 헤더

- HTTP는 필요에 따라 고쳐 쓸 수 있는 제어 헤더를 통해 다른 인증 프로토콜에 맞추어 확장할 수 있는 프레임워크를 제공한다.
- HTTP에는 기본인증과 다이제스트 인증이라는 두 가지 공식적인 인증 프로토콜이 있다.
- 아래는 인증 단계이다.

| 단계 | 헤더 | 설명 | 메서드/상태 |
| --- | --- | --- | --- |
| 요청 |  | 첫 번째 요청에는 인증 정보가 없다 | GET |
| 인증 요구 | WWW-Authenticate(인증)
오쎈터케이트 | 서버는 사용자에게 사용자 이름과 비밀번호를 제공하라는 지시의 의미로 401 상태 정보와 함께 요청을 반려한다.
서버는 각각 다른 비밀번호가 있는 영역들이 있을 것이므로, 서버는 WWW- Authenticate 헤더에 해당영역을 설명해 놓는다 | 401 Unauthorized |
| 인증 | Authorization(권한부여)
오써러제이션 | 클라이언트는 요청을 다시 보내는데 이번에는 인증 알고리즘과 사용자 이름과 비밀번호를 기술한 Authoriza-tion헤더를 함께 보낸다. | GET |
| 성공 | Authentication-Info | 인증 정보가 정확하면,서버는 문서와 함께 응답한다. 어떤 인증 알고리즘은 선택적인 헤더인 Authentication-info 인증 세션에 관한 추가 정보를 기술해서 응답하기도 한다. | 200 OK |
- 서버가 사용자에게 인증 요구를 보낼 대,서버는 401 Unauthorized 응답과 함께 WWW-Authenticate 헤더를 기술해서 어디서 어떻게 인증할지 설명한다.
- 클라이언트가 서버로 인증하려면, 인코딩된 비밀번호와 그 외 인증 파라미터들을 Authorization 헤더에 담아서 요청을 다시 보낸다. 인증이 성공적으로 완료되면, 서버는 정상 적인 상태 코드(200OK)를 반환하며 추가적인 인증알고리즘에 대한 정보를 Authentication-Info 헤더에 기술할 수도 있다.

## 12.1.3 보안 영역

- HTTP가 어떻게 각 리소스마다 다른 접근 조건을 다루는지 설명할 필요가 있다.
- 서버가 클라이언트로 인증 요구할때,realm 지시자가 기술되어 있는 WWW-Authenticate 헤더를 봤을 것이다. 웹서버는 기밀문서를 보안 영역(realm)그룹으로 나눈다.
- 보안 영역은 저마다 다른 사용자 권한을 요구한다.
- 사용자는 각기 다른 보안영역에 접근한다.
- realm은 아래와 같이 해설 형식으로 구성되어 사용자가 권한에 대한 범위를 이해하는데 도움이 되어야 하니다.
- 아래 예처럼 회사 Corporate Financials(재무 영역 그룹)에 경우 그에 해당하는 정보만 열람이 가능하게 됩니다.

![Untitled](12%20%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%8C%E1%85%B3%E1%86%BC%20641836a2203040b89b1a454d9ed27001/Untitled.png)

```html
HTTP/1.0 401 Unauthorized
WWW-Authenticate : Basic realm="Corporate Financials"
```

- 이름과 비밀번호를 가지고 있는 사용자가 권한의 범위를 이해하는데 도움이 되어야 한다.
- realm(렘): 영역

## 12.2 기본 인증

- 기본 인증은 가장 잘 알려진 HTTP 인증 규약이다.
- 기본 인증은 원래 HTTP/1.0에 기술되어 있었지만,HTTP인증의 상세 내용을 다루는 RFC 2617로 옮겨졌다.
- 기본 인증에서 웹 서버는 클라이언트의 요청을 거부하고 유효한 사용자 이름과 비밀번호를 요구할 수 있다. 서버는 200 대신 401 상태 코드와 함께 , 클라이언트가 접근 클라이언트가 접근하려고 했던 보안영역을 WWW-Authenticate에 기술해서 응답하여 인증 요구를 시작한다.
- 인증 정보를 포함하여 요청하라는 응답을 받은 브라우저는, 사용자에게 계정과 비밀번호를 입력할 수 있는 대화 상자를 연다. 여기서 계정과 비밀번호는 사용자가 해당하는 영역에 접근 권한이 있는지 검사하는데 사용된다. 브라우저는 사용자가 입력한 사용자 이름과 비밀번호를 Authorization 요청 헤더 안에 암호화 서버로 다시 보낸다.

### 12.2.1 기본인증의 예

| 인증요구/ 응답 | 헤더 문법과 설명 |
| --- | --- |
| 인증요구(서버에서 클라이언트로) | 각 사이트는 보안 영역마다 다른 비밀번호가 있을 것이다.
realm은 요청 받은 문서 집합의 이름을 따옴표로 감산 것이다. 
사용자는 이 정보를 보고 어떤 비밀번호를 사용했는지 알 수 있다.
 WWW-Authenticate : Basic realm=따옴표로 감싼 문서 집합 정보 |
| 응답(클라이언트에서 서버로) | 사용자 이름과 비밀번호는 콜론으로 잇고, base 64로 인코딩해서 사용자 이름과 비밀번호에 쉽게 국제 문자를 포함할 수 있게 하고 , 네트워크 트래픽에서 사용자 이름과 비밀번호가 노출 되지 않게한다.
 Authorization : Basic base-64로 인코딩한 사용자 이름과 비밀번호  |
- 기본인증 프로토콜은 Authentication-Info 헤더를 사용하지 않는 다는 점을 기억하자.

### 12.2.2 Base-64 사용자 이름 / 비밀번호 인코딩

- HTTP 기본 인증은 사용자 이름과 비밀번호를 클론으로 이어서 합치고, base-64 인코딩 메서드를 사용해서 인코딩한다.
- Base-64 인코딩은 8비트 바이트로 이루어져 있는 시퀀스를 6비트 덩어리의 시퀀스로 변환한다. 각 6비트 조각은 대부분 문자와 숫자로 이루어진 특별한 64개의 문자중에서 선택된다.
- 브라우저는 사용자 이름과 비밀번호를 콜론으로 이어서 하나의 문장을 만든다. 그러고 나서 이 문자열을 base-64로 인코딩해서 복잡한 문자열을 만든다.
- Base-64 인코딩은 바이너리, 텍스트, 국제 문자 데이터 문자열을 받아서 전송할 수 있게, 그 문자열을 전송 가능한 문자인 알파벳으로 변환하기 위해 발명 되었다. 전송중에는 원본 문자열이 변질 될 걱정 없이 원격에서 디코딩 할 수 있다.

### 12.2.3 프락시 인증

- 중개 프락시 서버를 통해 인증 할 수 도 있다. 어떤 회사는 사용자들이 회사 서버나 LAN이나 무선 네트워크 접근하기 전에 프락시 서버를 거치게 하여 사용자를 인증한다.
- 프락시 서버에서 접근 정책을 중앙 관리 할 수 있기 때문에, 회사 리소스 전체에 대해 통합적인 접근 제어를 하기 위해서 프락시 서버를 사용하면 좋다.
- 프락시 인증은 웹서버의 인증과 헤더와 상태 코드만 다르고 절차는 같다

| 웹 서버 | 프락시 서버 |
| --- | --- |
| 비인증 상태 코드 : 401 | 비인증 상태 코드 : 407 |
| WWW_Authenticate | Proxy-Authenticate |
| Authorization | Proxy-Authorization |
| Authorization-Info | Proxy-Authentication-info |

## 12.3 기본인증의 보안 결합

- 기본인증은 단순하고 편리하지만 아래와 같은 보안 결함이 생길 수 있다.
1. Base-64의 인코딩은 디코딩 할 수 있다.
2. 더 복잡하게 인코딩이 되어도 사용자 이름과 비밀번호를 캡처한 다음, 그것을 원 서버에 보내서 인증에 성공할 수 있다.
3. 무료 인터넷 이메일 같은 사이트에서 사용자 이름과 비밀번호 문자열을 그대로 캡처하고 동일한 사용자 이름과 비밀번호로 중요한 온라인 은행 사이트에 접근 할 수도 있다.
4. 트랜잭션의 본래 의도를 바꿔 버리는 프락시나 중개자가 중간에 개입하는 경우 기본인증은 정상 동작이 보장 하지 않는다.
5. 기본인증은 가짜 서버의 취약하가.
- 기본인증은 일반적인 환경에서 개인화나 접근을 제어하는데 편리하며, 다른 사람들이보지않기를 원하기는 하지만 , 보더라도 치명적이지 않을 경우에는 여전히 유용하다.

![Untitled](12%20%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%8C%E1%85%B3%E1%86%BC%20641836a2203040b89b1a454d9ed27001/Untitled%201.png)

![Untitled](12%20%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A9%E1%86%AB%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%8C%E1%85%B3%E1%86%BC%20641836a2203040b89b1a454d9ed27001/Untitled%202.png)