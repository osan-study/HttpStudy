# 10장 HTTP/2.0

## 10.1 HTTP/2.0의 등장 배경

- HTTP/1.1의 경우 커넥션 하나를 통해 요청 하나를 보내고 그에 대한 응답을 하나만 받는 HTTP 의 메시지를 교환 방식을 단순함 면에서는 더할 나위 없었지만, 응답을 받아야만 그 다음 요청을 보낼 수 있기때문에 심각한 회전 지연(latency)을 피할 수 없다.이 문제를 회피하기 위해 병렬 커넥션이나 파이프라인 커넥션이 도입되었지만 성능개선에 대한 근본적인 해결책은 되지 못했다.
- 이러한 문제를 해결하기 위해 2009년 구글은 웹을 더 빠르게 하겠다라는 목표아래 SPDY(스피디라고 읽는다)프로토콜을 내놓았다.
- SPDY는 헤더를 압축하여 대역폭을 절약했고, 하나의 TCP 커넥션에 여러 요청을 동시에 보내 회전 지연을 줄이는 것이 가능 했고 클라이언트가 요청을 보내지 않아도 서버가 능동적으로 리소스를 푸시하는 기능도 갖추고 있다.
- 마침낸 2012냔 10월 3일 HTTP 작업 그룹은 SPDY를 기반으로 HTTP/2.0프로토콜 설계하기로 결정하였음을 메일링 리스트를 통해 밝혔다.

## 10.2 개요

- HTTP/2.0은 서버와 클라이언트 사이의 TCP 커넥션 위에서 동작한다. 이때 TCP커넥션을 초기화하는 것은 클라이언트다.
- 하나의 커넥션 위에 여러개의 스트림이 동시에 만들어질 수 있으므로, 여러개의 요청과 응답을 동시에 처리하는 것 역시 가능하다. HTTP/2.0은 이들 스트림에 대한 흐름 제어와 우선순위 부여가능하다.
- 기존의 요청-응답과는 약간의 다른 새로운 상호작용 모델인 서버 푸시를 도입했다.

## 10.3 HTTP/1.1과의 차이점

- 모든 메시지는 프레임에 담겨 전송된다.
- 모든 프레임은 8바이트 크기의 헤더로 시작되며 , 뒤이어 16383바이트 크기의 페이로드가 온다.

![Untitled](10%E1%84%8C%E1%85%A1%E1%86%BC%20HTTP%202%200%20a56c93a6e44a495086c638b24f547f59/Untitled.png)

## 10.3.2 스트림과 멀티 플렉싱

- 스트림은 HTTP2.0 커넥션을 통해 클라이언트와 서버 사이에서 교환되는 프레임들의 독립된 양방향 시퀀스다.
- 한 쌍의 HTTP 요청과 응답은 하나의 스트림을 통해 이루어진다. 클라이언트는 새 스트림을 만들어 그를 통해 HTTP 요청을 보낸다.
- HTTP/1.1에서는 하나의 TCP 커넥션을 통해 요청을 보냈을 때, 그에 대한 응답이 도착하고 나서야 같은 TCP 커넥션으로 다시 요청을 보낼 수 있다
- HTTP/2.0에서는 하나의 커넥션에서 여러 개의 스트림이 동시에 가질 수 있다(멀티 플렉싱)
- 스트림은 우선순위를 가질 수 있다.
- 모든 스트림은 31비트의 무부호 정수로 된 고유한 식별자를 갖는다 스트림이 클라이언트에 의해 초기화되었다면 이 식별자는 반드시 홀수, 서버라면 반드시 짝수여야 한다. 새로 생성되는 스트림의 식별자는 이전 스트림 혹은 예약된 스트림보다 커야하며 규칙을 어기는 식별자를 받으면 PROTOCOL_ERROR라는 응답 코드의 커넥션 에러로 응답한다.
- 서버와 클라이언트는 스트림을 상대방과 협상없이 일방적으로 만들 수 있다.
- HTTP/2.0 커넥션에서 한번 사용한 스트림 식별자는 다시 사용할 수 없다.

## 10.3.3 헤더압축

- 요즘에는 웹페이지 하나를 보기 위해 수십에서 많으면 수백번의 요청을 보내기 때문에, 헤더의 크기가 회전 지역과 대역폭 양쪽 모두에 실질적인 영향을 끼치게 되었다.
- 이를 개선하기 위해 HTTP/2.0에서는 HTTP 메시지의 헤더를 압축하여 전송한다.
- HTTP/2.0에서는 HTTP 메시지의 헤더를 압축하여 전송한다.

## 10.3.4 서버 푸시

- 서버가 하나의 요청에 대해 응답으로 여러개의 리소스를 보낼 수 있도록 해준다.
- 이 기능은 서버가 클라이언트에서 어떤 리소스를 요구할 것인지 미리 알 수 있는 상황에서 유용하다.
- 예를 들어 html 문서를 요청 받았다면 해당 문서가 링크하고 있는 이미지, css, javascript 파일 등을 푸시한다.
- 리소스를 푸시하려는 서버는 먼저 클라이언트에 PUSH_PROMISE 프레임을 보내 푸시할 것임을 미리 알려야 한다(클라이언트가 해당 자원을 별도로 요청하는 상황을 막기 위해) 클라이언트가 이를 받으면 해당 프레임의 스트림은 클라이언트 입장에서 예약됨 상태가 된다. 클라이언트는 RST_STREAM 프레임을 보내어 푸시를 거절할 수 있다.
- 서버 푸시를 사용하기로 했더라도 중간의 프락시 서버로부터 받은 추가 리소스를 클라이언트에게 전달하지 않을 수 있으며, 반대로 아무런 추가리소를 서버로 부터 받지 않았음에도 클라이언트에게 추가 리소스를 전달 할 수도 있다.
- 서버 푸시를 사용하기로 했더라도, 중간의 프록시가 훼방을 놓을 수 있다
- 서버는 오직 안전하고, 캐시 가능하고, 본문을 포함하지 않는 요청에 대해서만 푸시를 할 수 있다
- 푸시할 리소스는 클라이언트가 명시적으로 보낸 요청과 연관된 것이어야 한다 -> 원 요청을 위해 만들어진 스트림을 통해 PUSH_PROMISE 프레임을 보냄
클라이언트는 반드시 서버가 푸시한 리소스를 CORS 정책에 따라 검사해야 한다.
- 서버 푸시를 끄고 싶다면 SETTING_ENABLE_PUSH를 0으로 설정한다.

## 10.4 알려진 보안 이슈

### 10.4.1 중개자 캡슐화 공격

- HTTP/2.0 메시지를 중간의 프락시(중개자)가 HTTP/1.1 메시지로 변환할 때 메시지의 의미가 변질될 가능성이 있다.
- 반대로 HTTP/1.1 메시지를 2.0으로 변환할 때는 이런 문제가 없음

### 10.4.2 긴 커넥션 유지로 인한 개인정보 누출 우려

- HTTP/2.0은 사용자가 요청을 보낼때 회전 지연을 줄이기 위해 클라이언트와 서버사이의 커넥션을 오래 유지하는 것을 염두에 두고 있다.이것은 개인정보의 유출에 악용될 가능성이 있다.