# 커넥션 관리

- HTTP는 어떻게 TCP 커넥션을 사용하는가?
- TCP 커넥션의 지연,병목,막힘
- 병렬 커넥션, Keep-alive 커넥션,커넥션 파이프라인을 활용한 HTTP의 최적화
- 커넥션 관리를 위해 따라야 할 규칙들

> **커넥션** : 서로를 이어주고 연결 시켜 주는 뜻을 가지고 있고, 대화할 때 자연스럽게 사용하려면 연결이라는 의미에 초점을 맞추면 쉽게 사용할 수 있습니다.
> 

## 4.1 TCP 커넥션

- 지구상의 컴퓨터와 네트워크 장비에서 널리 쓰이고 있는 패킷 교환 네트워크 프로토콜들의 계층화된 집합인 TCP/IP를 통해 이루어진다.
- 세계 어디서든 크라이언트 애플리케이션은 서버 애플리케이션으로 TCP/IP 커넥션을 맺을 수 있으며 일단 커넥션이 맺어지면 클라이언트와 서버 컴퓨터 간에 주고 받는 메시지들은 손실 혹은 손상되거나 순서가 바뀌지 않고 안전하게 전달된다.

****URL을 입력받은 브라우저가 수행하는 7단계 과정****

![Untitled](%E1%84%8F%E1%85%A5%E1%84%82%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%2029454b2bdb864f9ea1e2c7a5d72646ed/Untitled.png)

URL : [http://www.joes-hardware.com:80/power-tools.html](http://www.joes-hardware.com/power-tools.html)

1. [www.joes-hardware.com이라는](http://www.joes-hardware.xn--com-f42mh0r1y0a/) 호스트 명을 추출한다.
2. 이 호스트 명에 대한 IP 주소를 찾는다.[www.joes-hardware.com](http://www.joes-hardware.com/) -> 202.43.78.3
3. 포트번호(80)를 얻는다.
4. 202.43.78.3의 80포트로 TCP 커넥션을 생성한다.
5. 서버로 HTTP GET 요청 메시지를 보낸다.
6. 서버에서 온 HTTP 응답 메시지를 읽는다.
7. 커넥션을 끊는다.

### 4.1.1 신뢰 할 수 있는 데이터 전송 통로인 TCP

- TCP는 HTTP에게 신뢰할 만한 통신 방식을 제공한다.
- • TCP 커넥션 한쪽에 있는 바이트들은 반대쪽으로 순서에 맞게 정확히 전달된다.

### 4.1.2 TCP스트림은 세그먼트로 나뉘어 IP 패킷을 통해 전송된다.

- TCP는 IP 패킷(데이터그램)이라고 불리는 작은 조각을 통해 데이터를 전송한다.
- HTTP가 메시지를 전송하고자 할 경우, 현재 연결되어 있는 TCP 커넥션을 통해서 메시지 데이터의 내용을 순서대로 보낸다.
- TCP는 세그먼트라는 단위로 데이터 스트림을 잘게 나누고, 세그먼트를 IP 패킷이라고 불리는 봉투에 담아서 인터넷을 통해 데이터를 전달한다. 이모든 것은 TCP/IP 소프트웨어에 의해 처리되며, 그 과정은 HTTP 프로그래머에게 보이지는 않는다.

![Untitled](%E1%84%8F%E1%85%A5%E1%84%82%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%2029454b2bdb864f9ea1e2c7a5d72646ed/Untitled%201.png)

- 각 TCP 세그먼트는 하나의 IP 주소에서 다른 IP 주소로 IP 패킷에 담겨 전달된다.
    - IP 패킷 헤더(보통 20바이트)
    - TCP 세그먼트 헤더(보통 20바이트)
    - TCP 데이터 조각(0 혹은 그 이상의 바이트)
- IP 헤더는 발신자와 목적지 IP 주소,크기,기타 플래그를 가진다. TCP 세그먼트 헤더는 TCP 포트번호, TCP 제어 플래그, 그리고 데이터의 수서와 무결성을 검사하기 위해 사용되는 숫자값을 포함한다.

![Untitled](%E1%84%8F%E1%85%A5%E1%84%82%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%2029454b2bdb864f9ea1e2c7a5d72646ed/Untitled%202.png)

### 4.1.3 TCP 커넥션 유지하기

- 컴퓨터는 항상 TCP 커넥션을 여러 개를 가지고 있다. TCP는 포트번호를 통해서 여러개의 커넥션을 가지고 있다.
- 포트번호는 회사 직원의 내선전화와 같다. 회사의 대표 전화번호는 안내 데스크로 연결되고 내선전화는 해당 직원으로 연결 되듯이 IP주소는 해당 컴퓨터에 연결되고 포트 번호는 해당 애플리케이션으로 연결된다. TP 커넥션은 네 가지 값으로 이루어져 있다.

<발신지 IP 주소 , 발신지 포트, 수신지 IP 주소, 수신지 포트>

### 4.1.4 TCP 소켓 프로그래밍

- 운영체제는 TCP 커네션의 생성과 관련된 여러 기능을 제공한다. 소켓 API를 사용하면, TCP종단(endpoint) 데이터 구조를 생성하고, 원격 서버의 TCP 종단에 그종단 데이터를 연결하여 데이터 스트림을 읽고 쓸 수 있다.

![Untitled](%E1%84%8F%E1%85%A5%E1%84%82%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%20%E1%84%80%E1%85%AA%E1%86%AB%E1%84%85%E1%85%B5%2029454b2bdb864f9ea1e2c7a5d72646ed/Untitled%203.png)

### 4.2 TCP의 성능에 대한 고려

- HTTP가 TCP를 사용하기 때문에 HTTP는 TCP의 성능에 영향을 받는다.

### 4.2.1 HTTP 트랜잭션 지연

- URI에 있는 호스트 명을 IP주소로 변환하는데 시간이 걸린다.
- TCP 커넥션 설정 및 수백개의 HTTP 트랜 잭션이 만들어지는 소요시간
- 요청 메시지가 인터넷을 통해 전달 되고 서버에 의해서 처리되는데 까지는 시간이 소요된다.
- 웹 서버가 HTTP 응답을 보내는 시간

### 4.2.2 성능 관련 중요 요소

- TCP 커넥션의 핸드 쉐이크 설정
- 인터넷의 혼잡을 제어하기 위한 TCP의 느린 시작(slow-start)
- 데이터를 한데 모아 한번에 전송하기 위한 네이글 알고리즘
- TCP 편승 확인 응답을 위한 확인응답 지연 알고리
- Time_WAIT 지연과 고갈

### 4.2.3 TCP 커넥션 핸드셰이크 지연

- 어떤 데이터를 전송하든 새로운 TCP 커넥션을 열 때면,TCP 소프트웨어는 커넥션을 맺기 위한 조건을 맞추기 위해 연속적으로 IP 패킷을 교환한다.
- 작은 크기의 데이터 전송에 커넥션이 사용 된다면 이런 패킷 교환은 HTTP 성능을 크게 저하 시킬수 있다.

핸드셰이크 과정

1. 클라이언트는 새로운 TCP 커넥션을 생성하기 위해 작은 TCP 패킷을 서버에게 보낸다. 그 패킷은 ‘SYN’라는 특별한 플래그를 가지는데 요청이 커넥션 생성 요청이라는 뜻이다.
2. 서버가 그 커넥션을 받으면 몇 가지  커넥션 매개변수를 산출하고, 커넥션 요청이 받아들여졌음을 의미하는 ‘SYN’과 ‘ACK’플래그를 포함한 TCP 패킷을 클라이언트에게 보낸다.
3. 마지막으로 클라이언트는 커넥션이 잘 맺어졌음을 알리기 위해서 서버에게 다시 확인 응답 신호를 보낸다.(오늘날의 TCP는 클라이언트가 이확인 응답 패킷과 함께 데이터를 보낼 수 있다.)

HTTP 프로그래머는 TCP 커넥션의 패킷을 보지 못한다. 하지만 HTTP 트랙잭션이 그리 크지 않은 데이터를 주고 받으면 이 때의 지연은 TCP에서의 지연임을 예상해볼 수 있다.

TCP의 ACK 패킷은 HTTP 요청 메시지 전체를 담을 만큼 큰 경우가 많고, 대부분의 HTTP 요청 메시지(304)는 하나의 IP 패킷에도 담길 수 있을 정도이기 때문에, HTTP 트랜잭션 시간의 50%는 TCP에서 쓰인다.

따라서 이런 TCP 구성으로 인한 지연을 제거하는 것이, HTTP 성능 개선의 관건일 것이다.

현재는 얼추 해결된 문제이다.

### 4.2.4 확인 응답 지연

- TCP는 성공적인 데이터 전송을 보장하기 위해서 자체적인 확인 체계를 가진다.
- 각 TCP 세그먼트는 순번과 데이터 무결성 체크섬을 가진다.
- 확인 응답은 그 크기가 작기 때문에 , TCP는 같은 방향으로 송출 데이터 패킷과 확인 응답을 “편승(piggyback)”시킨다. TCP는 송출 데이터 패킷과 확인 응답을 하나로 묶음으로써 네트워크를 좀더 효율적으로 사용한다.
- 확인 응답이 같은방향으로 가는 데이터 패킷에 편승되는 경우를 늘리기 위해서 많은 TCP 스택은 “확인 응답 지연” 알고리즘을 구현한다.
- TCP 스택에 있는 매개변수를 수정할 때는, 지금 무엇을 하고 있는지 항상 잘 알고 수정해야한다. TCP설정을 수정하려고 한다면,TCP의 내부 알고리즘이 피하려고 하는 문제를 애플리케이션이 발생 시키지 않을 것이라고 확신 할 수 있어야한다.

### 4.2.5 TCP 느린시작(slow start)

- TCP의 데이터 전송 속도는 TCP 커넥션이 만들어진지 얼마나 지났는지에 따라 달라진다.
- TCP는 과부하를 방지 하기 위해서 커넥션이 생긴 직후에는 일부러 느린 속도로 시작하고, 이후 점진적으로 속도를 높여 나간다. 이것을 느린 시작이라고 한다.(급작스런 부하와 혼잡을 방지)
- TCP 느린 시작은 TCP가 한번에 전송할 수 있는 패킷의 수를 제한한다. 패킷이 성공적으로 전달됨에 따라 속도가 점점 빨라딘자. 그 이유는 처음 최대 속도를 제한 한 후 성공여부에 따라 속도 제한을 높이기 때문이다.

### 4.2.6 네이글(Nagle) 알고리즘과 TCP_NODELAY

- TCP는 아무리 작은 데이터(from 1바이트)라도 하더라도 전달할 수 있도록 데이터 스트림 인터페이스를 제공한다. 그러나 일반적으로 플래그와 헤더를 합쳐도 40바이트 가량이다.그래서 적은 데이터를 여러 패킷으로 나눠서 보내게 된다면 네트워크 성능은 떨어진다.
- 네이글 알고리즘은 네트워크 효율을 위해서 패킷을 전송하기 전에 TCP 데이터를 한 개로 합치는 알고리즘이다. 네이글 알고리즘은 세그먼트가 최대 크기 (1500바이트)가 되지 않으면 전송을 멈춘다.
- 다른 모든 패킷이 확인 응답을 받았을 때는 최대 크기보다 작아도 전송을 허용하지만, 그게 아니라면 데이터를 버퍼에 저장해두다가 충분한 양의 데이터가 쌓일 때에만 전송하는 식이다.
- 네이글 알고리즘의 문제점
    - 크기가 작은 HTTP 메시지는 패킷을 채우지 못하기 때문에 계속해서 데이터를 기다리고 지연될 수 밖에 없다.
    - 여기에 앞서 있던 확인 응답 지연과 동시에 사용될 경우, 데이터를 기다리면서도 확인응답은 지연되니 속도는 매우 느려지게 된다.
- HTTP 애플리케이션은 성능을 향상시키기 위해 HTTP 스택에 TCP_NODELAY 파라미터를 설정하여 네이글을 비활성하기도 한다.

### 4.2.7 TIME_WAIT의 누적과 포트 고갈

- TIME_WAIT 포트고갈은 실제 상황에서는 무제를 발생 시키지 않는다.
- TCP 커넥션의 종단에서 TCP 커넥션을 끊으면 종단에서는 커네션의 IP 주소와 포트번호를 메모리의 작은 제어 영역(control block)에 기록해놓는다. 이 정보는 같은 주소와 포트번호를 사용하는 새로운 TCP 커네션이 일정 시간동안에는 생성되지 않게 하기 위한 것이다.
- TCP 커넥션의 종단에서 TCP 커넥션을 끊으면 해당 포트는 2분 동안 어떠한 애플리케이션도 배정되지 않고 대기 상태로 놓인다.
- 앞서 TCP 커넥션을 만들기 위해서는 발신자의 IP와 PORT, 수신자의 IP와 PORT, 총 4가지 요소가 필요하다고 했다. 여기서 클라이언트의 IP, 서버의 IP와 PORT는 고정이다.즉 클라이언트의 포트만이 커넥션 속도의 기준이 될 것이다.이 때 클라이언트의 포트가 6만 개고, 대기 시간이 120초라고 한다면, 초당 500개 이상을 쓰면 반드시 겹치는 커넥션이 나올 것임을 알 수 있다.서버가 더 빨라져서 초당 500개 이상을 처리할 수 있지 않으면, 포트는 고갈될 것이다. 이 문제를 해결하기 위해 부하를 생성하는 장비를 사용하거나, 가상 IP 주소를 쓸 수도 있다.
- 포트 고갈 문제가 아니더라도 커넥션이 많아지면 전체적인 성능 저하가 발생할 수 있으니 조심해야 한다.

## 4.3 HTTP 커넥션 관리

### 4.3.1 흔히 잘못 이해하는 COnnection 헤더

- HTTP 메시지는 클라이언트에서 서버까지 중개서버들을 하나하나 거치면서 전달된다.
- 커넥션에만 적용될 옵션을 지정해야할 때가 있다.
- Connection 헤더에는 다음 세가지 종류의 토큰이 전달 될수 있기때문에 다소 혼란스러울 수 있다.
    - HTTP 헤더 필드명은 , 이 커네션에만 해당되는 헤더들을 나영한다.
    - 임시적인 토크값은 커넥션에 대한 비표준 옵션을 의미한다.
    - close값은 커넥션이 작업이 완료되면 종료 되어야 함을 의미한다.
- 커넥션 토큰이 HTTP 헤더 필드명을 가지고 있으면 , 해당 필드들은 현재 커넥션만을 위한 정보이므로 다음 커넥션에 전달하면 안된다.
- Connection  헤더에 있는 모든 헤더 필드는 메시지를 다른곳으로 전달하는 시점에 삭제 되어야한다.

### 4.3.2 순차적인 트랜잭션 처리에 의한 지연

- 컨넥션 관리가 제대로 이루어지지 않으면 TCP성능이 않좋아진다.
- 예를 들어 3개의 이미지가 있는 웹페이지가 있다고 해보자 이 페이지를 보여주려면 4개의 http 트랜잭션을 만들어야 한다. 각 트랙잭션이 새로운 커넥션을 필요로 한다면 커넥션을 맺는 데 필요한 지연과, 느린 시작 지연이 발생한다.여기에 사용자의 심리적인 지연 ( 사람은 이미지가 순차적으로 뜨는 것보다, 조금 더 느리더라도 한꺼번에 뜨는 것을 선호하고, 심지어 후자가 더 빠르다고 느낀다.) 도 있다.
    - 병렬(parallel) 커넥션 : 여러 개의 TCP 커넥션을 통한 동시 HTTP 요청
    - 지속(persistence) 커넥션 : 커넥션을 맺고 끊는 데서 발생하는 지연을 없애기 위한 TCP 커넥션의 재사용
    - 파이프라인(pipelined) 커넥션 : 공유 TCP 커넥션을 통한 병렬 HTTP 요청
    - 다중(multiplexed) 커넥션 : 요청과 응답에 대한 중재 (아직 실험적인 기술이다.)

## 4.4 병렬 커넥션

- 순차적인 방식은 너무 느리다.
- HTTP 트랜잭션은 병렬로 처리할 수 있다.

### 4.4.1 병렬 커넥션은 페이지를 더 빠르게 내려받는다.

- 브라우저는 HTML 페이지에 이어 객체들을 하나씩 내려받는 방식으로 웹 페이지를 보여줄 수 있다. 하지만 이 방식은 느리다.병렬 커넥션은 클라이언트가 여러 개의 커넥션을 맺음으로서 한 번예 여러 개의 트랙잭션을 처리할 수 있게 한다.
- 서버에 이미지를 내려 받을 경우 이미지들을 병렬로 내려받아 커넥션 지연이 겹쳐짐으로 써 총 지연시간이 줄어든다.

### 4.4.2 병렬 커넥션이 항상 더 빠르지 않는다.

- 클라이언트의 대역폭이 좁을 경우 이 제한된 대역폭 내에서 각 객체를 전송 받는 것은 느리기 때문에 성능상의 장점은 거의 없어진다.
- 다수의 커넥션은 메모리를 많이 소모하고 자체적인 성능 문제를 발생 시킨다.

### 4.4.3 병령 커넥션은 더 빠르게 “느껴질 수” 있다.

- 화면에 여러개의 객체가 동시에 보이면서 내려받고 있는 상황을 볼 수 있기 때문에 사용자는 더 빠르게 내려받고 있는 것처럼 느껴질때가 있다.

### 4.5 지속 커넥션

- 서버에 HTTP 요청을 하기 시작한 애플리케이션은 웹페이지 내의 이미지등을 가져오기 위해서 그 서버에 또 요청한다. 이 속성을 지역성(site locality)라 부른다. 따라서 http/1.1을 지원하는 기기는 처리가 완료 된 후에도 TCP 커넥션을 유지하여 앞으로 있ㅇ을 HTTP 요청에 재사용 할 수 있다.처리가 완료된 후에도 계속 연결된 상태로 있는 TCP 커넥션을 지속 커넥션이라고 불린다.
- 지속 커넥션은 클라이언트나 서버가 커네션을 끊기 전까지는 트랜잭션간에도 커넥션을 유지한다.

### 4.5.1 지속커넥션 vs 병렬 커넥션

- 병렬 커넥션에는 3가지의 단점이 있다.
    1. 트랜잭션마다 새로운 커넥션을 맺고 끊어서 시간과 대역폭이 소요된다.
    2. 각각의 새 TCP는 느린 시작 때문에 성능이 떨어진다.
    3. 실질적으로 연결 가능한 커넥션 수에 제한이 있다.
- 지속 커넥션은 이에 비해 몇 개의 장점이 있다. 커넥션을 맺기 위한 작업과 지연을 줄이고, 튜닝된 커넥션을 유지하고, 커넥션의 수는 줄여준다.
- 하지만 커넥션을 잘못 관리하면 커넥션은 점차 쌓이게 될 것이고, 이는 로컬 리소스와 클라이언트, 서버의 리소스에 불필요한 소모를 방치하게 된다.
- 지속 커넥션은 병렬 커넥션과 함께 사용될 때가 가장 효과적이다. 오늘날 웹 애플리케이션은 적은 수의 병렬 커넥션만 가지고, 그것을 `유지`한다.

### 4.5.2 HTTP/1.0의 Keep-Alive커넥션

- 많은 HTTP/1.0 브라우저와 서버들은 다소 실험적이었던 keep-alive 커넥션이라는 지속 커넥션을 지원하기 위해서 확장되었다. 아직 초기 상태라 상호운용과 관련된 설계에 문제가 있었음에도 널리 사용됐다.현재도 많은 클라이언트와 서버가 이 초기 keep-alive를 사용하고 있다. 이 문제는 HTTP/1.1 부터 해결되었다. (지속 커넥션이 개발된 이유다.)
- 연속적으로 생성된 커넥션 보다는 지속 커넥션이 맺고 끊는데 필요한 작업이 없어서 시간이 단축된다.

### 4.5.3 Keep-Alive 동작

- keep-alive는 HTTP/1.1 명세에서는 제외되었다. 이제 사용하지 않기로 결정된 것이다. 앞서 keep-alive의 문제가 해결되었다고 했는데, 그건 keep-alive를 대체할 기술이 개발되었기 때문이다. 그럼에도 불구하고 우리는 keep-alive를 배워야 하는데, 그 이유는 앞서 말했다시피 아직도 keep-alive가 많이 사용되고 있기 때문이다.HTTP 애플리케이션은 이를 처리할 수 있어야 한다.
- HTTP/1.0 keep-alive 커넥션을 구현한 클라이언트는 커넥션을 유지하기 위해 서버에 Connection:Keep-Alive 헤더를 보낸다. 서버는 또같은 것을 헤더에 포함시켜서 돌려주어야 한다.
- 이를 통해 커넥션을 끊지 않을 거라는 것을 추정할 수 있게 되고, 반대로 서버가 헤더를 포함시키지 않고 돌려줬다면 이에 대해 지원해주지 않는 서버, 즉 커넥션이 끊길 거라고 추정할 수 있게 된다.

### 4.5.4 Keep-Alive 옵션

- Keep-alive 동작은 Kepp-alive 헤더의 쉼표로 구분된 옵션들로 제어할 수 있다.
    - keep-alive의 동작은 헤더의 쉼표로 구분된 옵션으로 제어한다.
    - timeout 파라미터는 커넥션이 유지되는 시간을 의미한다. 물론 보장할 수는 없다.
    - max 파라미터는 커넥션이 몇 개의 트랜잭션을 교환할 때까지 유지할 것인가를 의미한다. 물론 보장할 수는 없다.
    - Keep-Alive 헤더는 진단이나 디버깅을 목적으로 하는, 임의의 속성들을 지원하기도 한다. 이는 `이름 = 값`의 형태로 작성된다.
    
    ```bash
    Connection: Keep-Alive
    Keep-Alive: max=5, timeout=120
    ```
    

### 4.5.5 Keep-Alive 커넥션 제한과 규칙

- 커넥션이 끊어지기 전에 엔터티 본문의 길이를 알아야 커넥션을 유지할 수 있다. 커넥션이 끝날 때, 기존 메시지의 끝과 새 메시지의 시작점을 알아야 하기 때문이다.
- 프락시와 게이트웨이는 Connection 헤더의 모든 규칙을 철저히 지켜야 한다. 단, 캐시에 넣기 전에는 Connection 헤더에 명시된 모든 헤더 필드와 Connection 헤더를 제거해야 한다.
- keep-alive 커넥션은 Connection 헤더를 인식하지 못하는 프락시를 피해야 한다. (현실적으로는 어렵다.)
- 기술적으로 HTTP/1.0을 따르는 모든 기기로부터 Connection 헤더 필드가 오면 무시하는 것이 옳다. 실수로 전달된 것일 가능성도 있기 때문이다.
- 클라이언트는 응답 전체를 모두 받기 전에 커넥션이 끊어질 경우, 요청을 다시 보낼 수 있게 준비되어 있어야 한다.

### 4.5.6 Keep-Alive와 멍청한(dumb) 프락시

- 프락시는 중간에서 처리해주는 비서같은 존재라고 생각이 든다.아무튼 프락시를 이용하면 서버가 일해야 되는 것을 대신 일을 해주기 때문에 서버 입장에서는 좋은 영향을 가지게된다.
- 멍청한 프락시에 keep-alive를 사용할때 생기는 문제에 대해 더 자세히 살펴보자
- **Connection 헤더의 무조건 전달**
    - 웹 클라이언트의 요청에 Connection 헤더가 있으면, 서버가 그리고 이 요구사항을 들어줄 생각이 있으면 똑같은 헤더를 반환한다, 이전에 말한 내용이다.문제는 프락시가, 헤더를 이해하지도 못하면서 있는 그대로 다음 프락시에게 전달해준다는 점이다. 중간에 이런 멍청한 프락시 하나가 끼어있는 네트워크가 있다고 해보자.
        1. 클라이언트는 Connection 헤더를 프락시 서버에게 보낸다. Connection 헤더는 hop-by-hop 헤더다. 다른 곳에 전달되어서는 안 된다.
        2. 멍청한 프락시는 자신에게 Connection을 유지해달라는 요청인지도 모르고 다음 프락시에게 보낸다. (다음 프락시는 서버라고 가정하자.)
        3. 서버는 멍청한 프락시에게 Connection 헤더를 받고, Connection을 유지해달라는 의미로 해석한다. 그래서 유지해준다. 즉 Connection 헤더를 돌려준다!
        4. 멍청한 프락시는 응답을 받고 다시 클라이언트에게 응답을 해줘야 한다. 그런데 서버가 준 응답에는 keep-alive가 있다. 그걸 이해하지도 못하면서 그대로 클라이언트에게 돌려준다!
        5. 클라이언트는 keep-alive가 성공했다고 생각한다!
        6. 멍청한 프락시는 모든 임무가 완수되었다고 생각하고 서버 측이 커넥션을 끊기를 기다린다. 그런데 서버는 끊지 않는다. 그래서 계속 기다린다.
        7. 이 때 만일 클라이언트가 메세지를 보내면, 멍청한 프락시는 한 커넥션에서 2개 이상의 트랜잭션이 생기는 것을 이해 못하기 때문에 새로운 요청을 무시한다.
        8. 브라우저는 자신(클라이언트)이나 서버가 타임아웃이 걸려서 커넥션이 끊길 때까지 기다린다.
- **프락시와 홉별 헤더**
    - 위의 `Connection 헤더의 무조건 전달`과 같은 오류를 피하기 위해서는, 프락시는 Connection 헤더와, Connection 헤더가 명시된 헤더들을 절대 전달하면 안 된다.
    - Connection 헤더가 들어오면, Connection 헤더 뿐만 아니라, Keep-Alive 란 이름의 헤더도 전달하면 안 된다는 의미이다. 또한 hop-by-hop 헤더들 역시 전달하거나 캐시해서는 안 된다.
    

### 4.5.7 Proxy-Connection 살펴보기

- 넷스케이프(현재 모질라와 파이어폭스의 전신 쯤 되는 회사)의 브라우저 및 프락시 개발자는 모든 웹 애플리케이션이 HTTP 최신 버전을 지원하지 않아도 위 문제를 해결할 방법을 모색하였다.
    
    그 방법은, Proxy-Connection 이라는 별도 헤더를 사용해보는 것이다. (모든 상황에서 해결책이 되줄 순 없다.)
    
    이는 멍청한 프락시들이, 위 헤더를 그대로 전달하더라도 서버 측에서 무시하게 만드는 방법이다.
    
    대신, 영리한 프락시들에게는 저 헤더가 의미하는 바를 알려줘서 Proxy-Connection을 받으면 Connection으로 변환해서 서버에게 전달하게 하는 것이다.
    
    문제는 이 영리한 프락시 이전이나 이후, 둘 중 하나에 멍청한 프락시가 있을 경우다. 이 경우에는 앞서 서술한 문제가 그대로 재현된다.
    
    Proxy-Connection은 Connection 헤더의 무조건 전달을, 단일 프락시인 경우에만 해결할 수 있는 방법이다.
    

### 4.5.8 HTTP/1.1의 지속 커넥션

- HTTP/1.1은 keep-alive 커넥션을 지원하지 않는 대신 설계적으로 더 개선된 지속 커넥션을 지원한다. 목적은 같음에도 더 잘 동작한다.
- HTTP/1.1에서는 지속 커넥션은 기본으로 활성화된다. HTTP/1.1은 별도 설정이 없는 한 모든 커넥션을 지속 커넥션으로 취급한다. HTTP/1.1은 반대로, 끊어야 할 때 Connection:close를 보내도록 한다.
- 물론 클라이언트나 서버는 임의로 끊을 수도 있다

### 4.5.9 지속 커넥션의 제한과 규칙

- 클라이언트가 요청에 Connection:close를 했으면, 이후에는 더 요청을 보낼 수 없다.
- **커넥션에 있는 모든 메시지가 자신의 길이 정보를 정확히 가지고 있을 경우에만 커넥션을 지속할 수 있다. (Content-Length)**
- HTTP/1.1 프락시는 클라이언트와 서버 각각에 별도의 지속 커넥션을 맺고 관리해야 한다.
- HTTP/1.1 프락시는 클라이언트의 지원 범위를 알고 있지 않은 한 지속 커넥션을 맺어서는 안 된다.
- HTTP/1.1 클라이언트는 Connection 헤더와는 무관하게 언제든지 연결을 끊을 수 있다.
- 클라이언트는 전체 응답을 받기 전에 커넥션이 끊어지면 다시 보낼 수 있어야 한다.
- 클라이언트는 과부하를 방지하기 위해서라도 사용자 1명 당 2개의 커넥션만을 준비한다. 마찬가지로 프락시나 서버도 그러하다.

## 4.6 파이프라인 커넥션

- HTTP/1.1은 지속 커넥션을 통해서 요청을 파이프라이닝할 수 있다. 이는 keep-alive 커넥션의 성능을 더 높여준다.
- 파이프라인은 응답을 기다리지 않고 요청을 보내는 방식이다. 파이프라인에는 제약이 있다.
    - HTTP 클라이언트는 커넥션이 지속 커넥션인지 확인하기 전까지는 파이프라인을 이어서는 안 된다. (지속 커넥션이 아니면 뒤의 요청이 무시 당한다.)
    - HTTP 응답은 요청 순서와 같아야 한다. HTTP 메시지는 순번이 없기 때문에 응답이 순서 없이 오면 정렬할 방법이 없다.
    - HTTP 클라이언트는 도중에 커넥션이 끊기더라도 다시 요청을 보낼 수 있어야 한다. 이 경우에는, 몇 개의 요청까지 성공했는지 확인할 방법이 있어야 한다.
    - HTTP 클라이언트는 POST 요청같이 반복해서 사용할 경우 문제가 생기는 요청은 파이프라인을 통해서 보내서는 안 된다. (멱등성에 대해서 알아보자.)
        - 어떤 것이 처리되었는지 클라이언트가 알 방법이 없다. 비 멱등한 메서드, 즉 위험한 메서드를 파이프라인으로 요청을 보내서는 안 된다.

## 4.7 커넥션 끊기에 대한 미스터리

- 커넥션 관리 (커넥션을 언제 어떻게 끊을 것인가)에 대한 기준은 없다. 개발자들이 알고 있는 것보다 더 미묘하며, 그에 관한 기술 문서도 별로 없다.

## 4.7.1 '마음대로' 커넥션 끊기

- 서버가 임의로 클라이언트와의 커넥션을 끊을 때, 서버는 사실 클라이언트가 요청을 보내지 않을 거라고 확신을 하고 끊는 것은 아니다. 그저 유휴 상태가 길어졌기 때문에 끊는 것이다.이 때 클라이언트가 요청을 보내 버린다면 당연히 문제가 될 수 밖에 없다. (이런 타이밍이 생길 수 있다는 것이 놀랍다.)

## 4.7.2 Content-Length와 Truncation

- 각 HTTP 응답은 본문의 정확한 크기 값을 가지는 Content-Length 헤더를 가지고 있어야 한다.
- 다만 일부 오래된 HTTP 서버는 자신이 커넥션을 끊으면 전송을 끝났음을 의미하는 형태로 개발되었기 때문에, Content-Length 헤더를 생략하거나 잘못된 길이 정보로 응답할 수도 있다.따라서 클라이언트나 프락시는 커넥션이 끊어졌다는 HTTP 응답을 받은 후, 실제 전달된 엔터티의 길이와 Content-Length의 값이 일치하지 않거나 Content-Length 자체가 존재하지 않을 경우,다시 서버에게 요청을 해볼 필요가 생긴다.
- 만약 수신자가 캐시 프락시일 경우 응답을 캐시해서는 안 된다. 프락시는 Content-Length를 정정하려 하지 말고 메시지를 받은 그대로 전달해야 한다.

## 4.7.3 커넥션 끊기의 허용, 재시도, 멱등성

- 수시로 말하지만 클라이언트는, 커넥션이 끊긴 경우 재요청을 할 수 있어야 한다. 문제는 파이프라인이다.
- 클라이언트는 여러 요청을 큐에 쌓아두고 전송해서 더 빨라질 수는 있지만, 도중에 커넥션이 끊어진다면 어디까지 전송되었는지 알 방법이 없다.
- 만일 GET 요청처럼 페이지를 띄우는 요청이었다면 다시 보내면 되겠지만, POST처럼 멱등하지 않은 요청을 반복한다면, 예컨대 구매하기 요청을 잘못 해석 해 중복 구매를 요청하게 될 수도 있다.따라서 파이프라인은, 원칙적으로 안전한 메서드에 한하여 사용해야 한다.
- 비멱등인 요청을 다시 보내야 한다면, 이전 요청에 대한 응답이 돌아올 때까지 일단 기다려야 한다.
- - 비멱등 메서드는 함부로 사용하지 말것!

## 4.7.4 우아한 커넥션 끊기

- TCP 커넥션은 양방향 Queue 구조이다. 클라이언트는 입력과 출력을 가지고 있고, 서버도 입력과 출력을 가지고 있다. 서로의 출력은 상대의 입력 방향으로 보내질 것이다.
- **전체 끊기와 절반 끊기**
    - 애플리케이션은 TCP 입력 채널과 출력 채널 중 한 개만 끊거나 둘 다 끊을 수 있다. close()로 둘 다 끊을 때를 전체 끊기, shutdown()으로 한 개만 끊을 때를 절반 끊기라고 한다.
- **TCP 끊기와 리셋 에러**
    - HTTP 애플리케이션들 중 일부는 예상치 못한 쓰기 에러를 방지하기 위해 절반 끊기를 사용한다. 보통 커넥션의 출력 채널을 끊는 것이 안전하다. (자신이 말하지 않는다는 의미)그러면 커넥션 반대 쪽의 기기는 버퍼를 모두 읽고 난 다음에 커넥션이 끊겼음을 인지한다.
    - 클라이언트에서 더 데이터를 보내지 않을 거라고 확신할 수 없는 이상, 커넥션의 입력 채널을 끊는 것은 위험하다. 입력이 끊긴 채널에 데이터를 보내면 운영체제는 TCP 'connection reset by peer'를 보낸다.
    - 운영체제는 이것을 심각한 에러로 취급하여 아직 읽히지 않은 데이터를 모두 삭제한다.
- **우아하게 커넥션 끊기**
    - HTTP 명세에서는 우아하게 커넥션을 끊으라고 되어 있지만 방법은 서술되어 있지 않다.
    - 일반적으로 우아한 방법은, 자신의 출력 채널을 먼저 끊고, 상대방이 출력 채널을 끊기를 기다리는 것이다. 그러면 자동적으로 자신의 양쪽 모두 데이터 전송이 중단되었음을 알 수 있다.이 때 커넥션은 리셋의 위험 없이 온전히 종료된다. 그러나 안타깝게도 자신이 먼저 끊어도 상대방은 그것에 대한 대응 로직이 없을 수도 있다. 그래서 기다린다고 해도 소용 없을 수 있다.따라서 커넥션을 우아하게 끊고자 한다면, 자신의 출력 채널을 끊은 다음에 상대방이 일정 시간 끊지 않으면 스스로 끊게끔 해야 한다.
