# 7장 캐시

- 웹 캐시는 자주 쓰이는 문서의 사본을 자동으로 보관하는 HTTP 장치다
- 데이터나 값을 미리 복사해 놓는 임시 저장소
- 웹 요청이 캐시에 도착했을 때, 캐시 된 로컬 사본이 존재 한다면 , 그 문서는 원 서버가 아니라 그 캐시로 부터 제공 된다.

## 캐시의 장점

- 캐시는 불필요한 데이터 전송을 줄여서 , 네트워크 요금으로 인한 비용을 줄여 준다.
- 캐시는 네트워크 병목을 줄여준다. 대역폭을 늘리지 않고도 페이지를 빨리 불러 올 수 있게 된다.
- 캐시는 원 서버에 대한 요청을 줄여준다. 서버는 부하를 줄일 수 있으며 더 빨리 응답할 수 있게 된다.
- 페이지를 먼 곳에서 불러올 수록 시간이 많이 걸리는데, 캐시는 거리로 인한 지연을 줄여준다.

## 7.1 불필요한 데이터 전송

- 복수의 클라이언트가 쓰이는 원 서버 페이지에 접근할 때 서버는 같은 문서를 클라이언트들에게 각각 한번 씩 전송하게 된다. 똑같은 바이트들이 네트워크를 통해 계속 반복해서 이동한다.
- 캐시를 이용하면 , 첫번째 서버 응답은 캐시에 보관된다. 캐시 된 사본이 뒤이은 요청들에 대한 응답으로 사용 될 수 있기 때문에, 원 서버가 중복해서 트래픽을 주고 받는 낭비가 줄어 들게 된다.

## 7.2 대역폭 병목

- 캐시는 또한 네트워크 병목을 줄여준다.
- 캐시는 불필요한 데이터 전송을 줄여 대역폭을 늘리지 않고도 페이지를 빨리 불러올 수 있게 한다.
- 네트워크 종류의 차이 따라 극적으로 달라진다.

## 7.3 갑작스런 요청 쇄도(Flash Crowds)

- 캐싱은 갑작스런 요청 쇄도에 대처하기 위해 특히 중요하다.
- 이러한 경우 캐싱은 웹 서버의 과부화를 막는데 도움을 준다.

## 7.4 거리로 인한 지연

- 보통 수준으로 복잡한 웹페이지들은 빛의 속도로 인한 지연이 수 초에 달할 수도 있다.

## 7.5 적중과 부적중

- 캐시에 요청이 도착했을 때, 만약 그에 대응하는 사본이 있다면 그를 이용해 요청이 처리될 수 있다. **(캐시 적중:cache hit)**
- 만약 대응하는 사본이 없다면 그냥 원 서버로 전달되기만 할 뿐이다.**(캐시 부적중 : cache miss)**

### **7.5.1 재검사(Revalidation)**

- 원 서버 콘텐츠는 변경될 수 있기 때문에 , 캐시는 반드시 그들이 갖고 있는 사본이 여전히 최신인지 서버를 통해 때때로 점검해야 한다.
- 신선도 검사를 재 검사라고 부른다.
- 캐시는 스스로 원한다면 언제든지 사본을 재 검사할 수 있다. 사본이 검사를 할 필요가 있을 정도로 충분히 오래된 경우에만 재 검사를 한다.
- 사본의 재 검사가 필요할 때 , 원 서버에 작은 재 검사를 요청한다.
    - 콘텐츠가 변경되지 않았다면, 서버는 아주 작은 304 Not Modified 응답을 보낸다.
    - 그 사본이 여전히 유효함을 알게 된 캐시는 즉각 사본이 신선하다고 임시로 다시 표시한 뒤 그 사본을 클라이언트에 제공한다.
- HTTP는 캐시 된 객체를 재확인하기 위한 몇 가지 도구를 제공한다.
    - If-Modified-Since 헤더를 사용한다.
    - 서버에게 보내는 GET 요청에 이 헤더를 추가하면 캐시 된 시간 이후에 변경된 경우에만 사본을 보내 달라는 의미가 된다.
    - **GET If-Modified_since 요청이 서버에 도착했을 때 일어날 수 있는 세가지 상황**
        - **재검사 적중**
            - 만약 서버 객체가 변경되지 않았다면 서버는 클라이언트에게 작은 HTTP 304 Not Modified응답을 보낸다
        - **재검사 부적중**
            - 만약 서버 객체가 캐시된 사본과 다르다면, 서버는 콘텐츠 전체와 함께 평범한 HTTP 200 OK 응답을 클라이언트에게 보낸다.
        - **객체 삭제**
            - 만약 서버 객체가 삭제되었다면, 서버는 404 Not Found 응답을 돌려보매녀 캐시는 사본을 삭제한다.

### 7.5.2 적중률

- 캐시가 요청을 처리하는 비율을 캐시 적중률, 혹은 문서 적중률이라고 부르기도 한다.
- 적중률은 0에서 부터 1까지의 값으로 되어있지만,흔히 퍼센트로 표현되기도 한다.
- 오늘날 적중률이 40%면 웹 캐시로 괜찮으면 편이다.(100%면 모든 캐시 적중 0%는 캐시 부적중)

### 7.5.3 바이트 적중률

- 문서들은 모두 같은 크기가 아니기 때문에 문서 적중률이 모든 것을 말해주지 않는다.
- 어떤 사람들은 바이트 단위 적중률 측정값을 더 선호한다.
- 바이트 단위 적중률은 캐시를 통해 제공된 모든 바이트의 비율을 표현한다.
- 문서 적중률과 바이트 단위 적중률은 둘다 캐시 성능에 대한 유용한 지표다.
- 문서 적중률은 얼마나 많은 웹 트랜잭션을 외부로 내보내지 않았는지 보여준다.
- 문서 적중률은 개선하면 전체 대기신간이 줄여든다.

### 7.5.4 적중과 부적중의 구별

- 캐시가 적중이거나 부적중했는지 클라이언트는 항상 응답으로 `200 OK`를 받으므로 알 길이 없다. 이러한 경우`Date` 헤더를 이용하여 현재 시각과 비교하여 응답의 생성일이 더 오래되었다면 클라이언트는 응답이 캐시된 것임을 알아낼 수 있다. 캐시된 응답을 감지하는 또 다른 방법으로 응답이 얼마나 오래되었는지 말해주는 `Age` 헤더를 이용하는 것이다

## 7.6 캐시 토폴로지

- 캐시는 한명의 사용자에게만 할당 될 수도 있고 반대로 수천명의사용자들간에 공유 될수도 있다.
- 한명에게만 할당된 캐시를 개인 전용 캐시(Private Cache)라고 부른다.
- 공유 된 캐시는 공용 캐시(Public cache)라고 불린다.

### 7.6.1 개인 전용 캐시

- 개인 전용 캐시는 많은 에너지나 저장 공간을 필요로 하지 않으므로, 작고 저렴할 수 있다.
- 웹 브라우저는 개인 전용 캐시를 내장하고 있다.

### 7.6.2 공용 프락시 캐시

- 로컬 캐시에서 문서를 제공하거나, 혹은 사용자의 입장에서 서버에 접근한다.
- 공용캐시는 여러 사용자가 접근하기 때문에 불필요한 트래픽을 줄일 수 있는 더 많은 기회가 있다.

### 7.6.3 프락시 캐시 계층들

- 두 단계 캐시 계층으로 나누어 클라이언트 주위에는 작고 저렴한 캐시를 이용하고, 계층 상단에는 많은 사용자들에 의해 공유되는 문서를 유지하기 위해 더 크고 강력한 캐시를 사용하자는 것.

### 7.6.4 캐시망,콘텐츠 라우팅,피어링

- 몇몇 네트워크 아키텍처는 단순한 캐시 계층 대신 복잡한 캐시망을 만든다. 캐시망의 프락시 캐시는 복잡한 방법으로 서로 대화 하여 , 어떤 부모캐시와 대화할것인지 아니면 요청이 캐시를 완전히 우회해서 원 서버로 바로 가도록 할것인지에 대한 캐시 커뮤니케이션 결정을 동적으로 내린다.
    - URL에 근거하여 부모 캐시와 원 서버 중 하나를 동적으로 선택
    - URL에 근거하여 특정 부모 캐시를 동적으로 선택
    - 부모 캐시에게 가기 전에, 캐시된 사본을 로컬에서 찾아본다.
    - 다른 캐시들이 그들의 캐시된 콘텐츠에 부분적으로 접근할 수 있도록 허용하되, 그들의 캐시를 통한 인터넷 트랜짓(트래픽이 다른 네트워크로 건너가는것)은 허용하지 않는다.
- 이러한 복잡한 캐시 관계는 서로다른 조직이 상호 이득을 위해 그들의 캐시를 연결하여 서로 찾아볼 수 있게 해주며, 선택적인 피어링을 지원하는 캐시는 형제 캐시라고 불린다.

## 7.7 캐시 처리 단계

1. 요청 받기 : 캐시는 네트워크로 부터 도착한 요청 메시지를 읽는다.
2. 파싱  : 캐시는 메시지를 파싱하여 URL 과 헤더들을 추출한다.
3. 검색 - 캐신느 로컬 복사본이 있는지 검사하고, 사본이 없다면 사본을 받아온다(로컬로 저장)
4. 신선도 검사 : 캐시는 캐시된 사본이 충분히 신선한지 검사하고, 신선하지 않다면 변경사항이 있는지 서버에게 물어본다.
5. 응답 생성 : 캐시는 새로운 헤더와 캐시된 본문으로 응답 메시지를 만든다.
6. 발송 : 캐시는 네트워크를 통해 응답을 클라이언트에게 돌려준다.
7. 로깅 : 선택적으로, 캐시는 로그 파일에 트랜잭션에 대한 서술한 로그 하나를 남긴다.
8. 캐시 처리 플로 차트

![Untitled](7%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8F%E1%85%A2%E1%84%89%E1%85%B5%20985496de88674ba08383f32fb624a061/Untitled.png)

## 7.8 사본을 신선하게 유지하기

- HTTP는 어떤 캐시가 사본을 갖고 있는지 서버가 기억하지 않더라도, 캐시된 사본이 서버와 충분히 일치하도록 유지할 수 있게 해주는 단순한 메커니즘을 갖고 있다.
- HTTP는 이 단순한 메커니즘을 문서 만료와 서버 재검사라고 부른다.

### 7.8.1 문서 만료

- HTTP는 Cache-Control과 Expires라는 특별한 헤더들은 이용해서 원 서버가 각 문서에 유효기간을 붙일 수 있게 해준다.
- 캐시 문서가 만료되기 전에, 캐시는 필요하다며 서버와의 접촉 없이 사본을 제공할 수 있다.
- 캐시 문서가 만료되면, 캐시는 반드시 서버와 문서에 변경된 것이 있는지 검사해야하며 만약 그렇다면 신선한 사본을 얻어와야 한다.

### 7.8.2 유효기간과 나이

- 서버는 응답 본문과 함께 하는 , HTTP/1.+ Expires나 HTTP/1.1 Cache-Control: max-age 응답 헤더를 이용해서 유효기간을 명시한다. Expires와 Cache-Control:max-age헤더는 기본적으로 같은 일을 하지만, 절대 시간은 컴퓨터의 시계가 올바르게 맞추어져 있을 것을 요구한다.

### 7.8.3 서버 재검사

- 캐시된 문서가 만료 되었다는 것은, 그 문서가 원 서버에 현재 존재하는 것과 실제로 다르다는 것을 의미하지는 않으며, 다만 이제 검사할 시간이 되었음을 뜻한다.(서버 재검사)
    - 재검사 결과 콘텐츠가 변경 되었다면, 캐시는 그 문서의 새로운 사본을 가져와 오래된 데이터 대신 저장한 뒤 클라이언트에게도 보내준다.
    - 재검사 결과 콘텐츠가 변경되지 않았다면, 캐시는 새 만료일을 포함한 새 헤더들만 가져와서 캐시 안의 헤더들을 갱신한다.

### 7.8.4 조건부 메서드와의 재검사

- HTTP의 조건부 메서드는 재검사를 효율적으로 만들어준다. HTTP는 캐시 가 서버에게 “조건부 GET”이라는 요청을 보낼 수 있도록 해준다. 이 요청은 서버가 갖고 있는 문서가 캐시가 갖고 있는 것과 다른 경우에만 객체 본문을 보내달라고 하는것이다.
- HTTP는 다섯가지 조건부 요청 헤더를 정의 한다. 그중 If-Modified-Since와 If-None-Match이다.

### 7.8.5 If-Modified-Since: 날짜 재검사

- 흔히 'IMS' 요청으로 불린다.
- 서버에게 리소스가 특정 날짜 이후로 변경된 경우에만 요청 본문을 보내달라고 한다.
- 서버 응답 헤더의 Last-Modified 헤더와 함께 동작
- 캐시는 문서가 캐시된 날짜를 IMS에 보관하고, 원 서버는 제공하는 문서의 최근 변경 일시를 LM에 붙인다.
- IMS와 LM을 비교해서 IMS 날짜 이후에 서버의 문서가 변경되었다면, 원 서버는 새 문서를 주고 그렇지 않다면, 304 Not Modified 응답을 돌려준다.

### 7.8.6 If-None-Match : 엔터티 태그 재검사

- 어떤 문서는 내용에 아무런 변화가 없더라도 변경 시각이 바뀔 수 있다.
- 어떤 문서의 변경은 철자나 주석처럼 다시 읽어들이기 사소할 수 있다.
- ETag를 비교해서 다를 때만 요청을 처리한다.

```jsx
요청: If-None-Match: "v2.6"
응답: 304 Not Modified, ETag: "v2.6"
```

![Untitled](7%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8F%E1%85%A2%E1%84%89%E1%85%B5%20985496de88674ba08383f32fb624a061/Untitled%201.png)

 만약 서버의 ETag가 변경되었다면, 서버는 200 OK와 함께 새 콘텐츠를 새 ETag와 함께 반환

### 7.8.7 약한 검사기와 강한 검사기

- 캐시는 캐시된 버전이 서버가 갖고 있는 것에 대한 최신인지 확인하기 위해 엔터티 태그를 사용한다. 엔터티 태크와 최근 변경일시는 둘다 캐시 검사기다
- 강한검사기는 콘텐츠가 바뀔 때마다 바뀐다.
- 약한검사기는 어느정도 콘텐츠 변경을 허용하지만, 콘텐츠의 중욯란 의미가 변경되면 함께 변경된다.

### 7.8.8 언제 엔터티 태그를 사용하고 언제 Last-Modified 일시를 사용하는가?

- HTTP /1.1 클라이언트는 만약 서버가 엔터티 태그를 반환했다면, 반드시 엔터티 태그 검사기를 사용해야한다.
- 엔터티 태그 반환한 경우 엔터티 태그 검사기 사용한다
- Last-Modified 값만 반환한 경우 If-Modified-Since 검사 사용를 한다.

## 7.9 캐시 제어

### 7.9.1 no-cache와 no-store 응답 헤더

- no-store : 응답된 캐시가 그 응답의 사본을 만드는 것을 금지
- no-cache : 표시괸 응답은 사설 로컬 캐시 저장소에 저장된다. 다만 먼저 서버와 재검사를 하지 않고사는 캐시에서 클라이언트로 제공할 수 없다

### 7.9.2 Max-Age 응답 헤더

- 신선하다고 간주되었던 문서가 서버로부터 온 이후로 흐른 시간이고, 초로 나타낸다

### 7.9.3 Expires 응답헤더

- 더 이상 사용하지 않기를 권하는 이 헤더는 초 단위의 시간 대신 실제 만료 날짜를 명시한다

### 7.9.4 Must-Revalidate 응답헤더

- 캐시가 이 객체의 신선하지 않은 사본을 원 서버와의 최초의 재검사 없이는 제공해서는 안됨을 의미한다

### 7.9.5 휴릭스틱 만료

### 7.9.6 클라이언트 신선도 제약

### 7.9.7 주의할 점

## 7.10 캐시 제어 설정

### 7.10.1 아파치로 HTTP 헤더 제어하기

- mod_headers: 개별 헤더들을 설정

```tsx
<File *.html>
  Header set Cache-control no-cache
</Files>
```

- mod_expires: `Expires` 헤더를 자동으로 생성하는 프로그램 로직을 제공한다.
- mod_cern_meta: HTTP 헤더들의 파일을 특정 객체와 연결시켜줌

### 7.10.2 HTTP-EQUIV를 통한 HTML 캐시 제어

- 이 태그는 HTML 문서의 최상단에 위치하여 문서와 연동되어야 하는 HTTP 헤더들을 정의한다.

> 그러나 이 방법은 문서의 캐시 동작을 제어하는 서투른 방법으로, 유일하게 확실한 방법은 올바르게 설정된 서버가 보내온 HTTP 헤더를 이용하는 것이다.
> 

## 7.11 자세한 알고리즘

### 7.11.1 나이와 신선도 수명

- 문서의 나이는 서버가 문서를 보낸 후 그 문서가 나이를 먹은 시간의 총합이다
- 문서의 신선도 수명은 아직 문서가 신선하다고 볼 수 있는 수명이다

### 7.11.2 나이 계산

- 응답의 나이는 응답이 버서에서 생성되었을(혹은 서버로부터 재검사되었을) 때부터 지금까지의 총 시간이다.
- 그 나이는 응답이 인터넷상의 라우터들과 게이트웨이 들이 사이를 떠돌아다닌 시간(중개 캐시에 기록되어 있다)과 응답이 캐시에 머물러 있던 시간을 포함한다.

**겉보기 나이는 Date 헤더에 기반한다.**

- 모든 컴퓨터가 똑같이 정확한 시간을 갖고 있다면 단순히 `현재시간 - 문서를 보낸시간`으로 계산할 수 있다.
- 두 컴퓨터의 시계 설정차이로 인한 클록 스큐 문제가 발생할 수 있고 이로 인해 겉보기 나이는 종종 부정확화며 때론 음수가 될 수있다.

**점층적 나이 계산**

- 클록 스큐를 해결하기 위해 프락시나 캐시를 통과할 때마다 Age 헤더에 상대적인 나이를 누적해서 더하도록 한다.
- 이 방법은 내부 시계를 사용하여 체류 시간 계산하기 때문에 서버간 시간비교나 종단 시간 비교가 필요 없기 때문에 유용하다.

**네트워크 지연에 대한 보상**

- 트랜잭션은 느려질 수 있으며 이는 캐시의 주된 동기이다.
- 매우 느린 네트워크, 과부하 서버, 트래픽등의 발생은 문서의 나이 추정에 대한 추가 계산이 필요하다.
- 서버에서 캐시로의 단방향 네트워크 지연을 측정하는 쉬운 방법은 없지만, 왕복 지연을 계산하는 것은 상대적으로 쉽다.

### 7.11.3 완전한 나이 계산 알고리즘

**서버가 명시한 신선도 한계 계산**

```jsx
휴리스틱 = false
if (max-age 값이 설정되었나?) {
  서버 신선도 한계 = max_age 값
} else if (expires 값이 설정되었나?) {
  서버 신선도 한계 = expires 값 - date 값
} else if (Last_Modified 값이 설정되었나?) {
// Last_Modified 값이 있는 경우에도 만료 시간은 알 수 없기 때문에 휴리스틱을 이용한다.3
  마지막으로 변경된 시각 = max(0, date 값 - last_modified 값)
  서버 신선도 한계 = 마지막으로 변경된 시각 * lm 인자
  휴리스틱 = true
} else {
  서버 신선도 한계 = 캐시 최소 수명 기본값
  휴리스틱 = true
}

if (휴리스틱) {
  if (서버 신선도 한계 > 캐시 최대 수명 기본값) {
    서버 신선도 한계 = 캐시 최대 수명 기본값
  }
  if (서버 신선도 한계 < 캐시 최소 수명 기본값) {
    서버 신선도 한계 = 캐시 최소 수명 기본값
  }
}

return 서버 신선도 한계
```

**클라이언트가 수정한 신선도 한계**

```jsx
나이 한계 = 서버 신선도 한계() // 위 코드에서 계산한 것

// Max-Stale = <s>: <s>초 지난 것도 받아들임
if (Max-Stale 값이 설정되었나?) {
  if (Max-Stale 값 == INT_MAX) {
    나이 한계 = INT_MAX
  } else {
    나이 한계 = 서버 신선도 한계() + Max_Stale 값
  }
}

// Min-Fresh = <s>: <s>초 미만으로 남은 건 안 받음 
if (Min-Fresh 값이 설정되었나?) {
  나이 한계 = min(나이 한계, 서버 신선도 한계() - Min-Fresh 값)
}

// Max-Age <s>: 최대 나이
if (Max-Age 값이 설정되었나?) {
  나이 한계 = min(나이 한계, Max-Age 값)
}
```

### 7.11.4 신선도 수명 계산

### 7.11.5 완전한 서버 신선도 알고리즘

## 7.12 캐시와 광고

캐시는 사용자를 도와 더 좋은 경험을 제공하고, 네트워크 사업자들이 트래픽을 줄일 수 있도록 지원하지만 아래와 같은 문제가 있을 수 있다.

- 광고 콘텐츠 제공과 관련하여 캐시로 인해 원 서버가 HTTP 접근을 수신하지 않게 되어 만약 접근 횟수로 돈을 번다면 문제가 있을 수 있다.
- 이를 캐시가 가로채지 못하도록 ‘캐시 무력화'기법을 사용하는데 이러한 광고 시청 수를 관리하려는 시도는 캐싱의 긍정적인 효과를 감소시킨다.
- 대안으로 원 서버와 재검사하도록 캐시를 설정하는 것이 있지만 이는 트랜잭션을 느리게 만든다.

### 7.12.1 광고 회사의 딜레마

- 많은 콘텐츠 제공자가 광고를 통해 돈을 번다. 그러나 캐시는 원 서버가 실제 접근 횟수를 알 수 없게 숨길 수 있다. 만약 캐싱이 동작한다면 서버는 접근을 수신하지 않는다. 만약 접근 횟수에 따라 돈을 벌고 있다면, 이는 달갑지 않은 일일 것이다

### 7.12.2 퍼블리셔의 응답

- 콘텐츠 제공자는 캐시가 그들의 트래픽을 흡수하도록 내버려두어야하며, 캐시는 그들에게 적중이 얼마나 많이 일어났는지 알려주어야한다

### 7.12.3 로그 마이그레이션

- 이상적인 해결책은 서버로 요청이 가지 않도록 하는 것이다.
- 불행히도, 적중 로그는 그 크기 때문에 옮기기 어렵다.

### 7.12.4 적중 측정과 사용량 제한

- 캐시 적중 횟수를 정기적으로 서버에 돌려주는 Meter 헤더를 추가하면 적중 횟수를 측정할 수 있다.