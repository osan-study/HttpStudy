# 14장 보안 HTTP

## 14.1 HTTP를 안전하게 만들기

- 웹은 안전한 방식의 HTTP를 필요로 한다.
- 인증과 메시지 무결성을 제공하는 가벼운 방법은 보안 자료 접근 , 대량 구매 및 은행 업무에 충분히 강력하지 않다.
    - 서버 인증: 클라이언트는 진짜 서버와 통신함을 알 수 있어야 한다.
    - 클라이언트 인증: 서버는 진짜 클라이언트와 통신함을 알 수 있어야 한다.
    - 무결성: 데이터의 위조에 대해 안전 해야 한다.
    - 암호화: 도청에 대한 보안
    - 효율: 알고리즘은 충분히 빨라야 한다
    - 편재성: 모든 클라이언트와 서버에서 지원되어야 한다.
    - 관리상 확장성: 즉각적인 보안 통신을 할 수 있어야 한다.
    - 적응성: 최선의 보안 방법을 지원해야 한다.
    - 사회적 생존성: 사회 문화적, 정치적 요구를 만족 시켜야 한다.

## 14.1.1 HTTPS

- HTTPS는 HTTP를 안전하게 만드는 방식 중 에서 가장 인기가 있다.
- 웹페이지에서 HTTP가 아닌 HTTPS로 접근하는 경우 URL에 http:// 대신 [https://](https://로) 로 시작하는 것을 알 수 있다.
- HTTPS를 사용할 때, 모든 HTTP요청과 응답 데이터는 네트워크로 보내지기 전에 암호화 된다.
- HTTPS는 HTTP의 하부에 전송 레벨 암호 보안 계층을 제공함으로써  동작하는데 , 이 보안 계층은 안전 소켓 계층(Secure Sockets Layer, SSL) 혹은 그를 계승한 전송 계층 보안(Transpot Layer Security,TLS)를 이용하여 구현된다.(SSL이라는 표현으로 보안 계층을 표현한다)
- 어려운 인코딩 및 디코딩 작업은 대부분 SSL 라이브러리 안에 일어나기 때문에 보안 HTTP를 사용하기 위해 웹 클라이언트와 서버가 프로토콜을 처리하는 로직을 크게 변경할 필요는 없다.
- 대부분의 경우 TCP 입력/출력 호출을 SSL 호출로 대체하고, 보안정보를 설정하고 관리 하기 위한 몇 가지 호출을 추가하기만 하면 된다.

## 14.1.2 디지털 암호화

| 암호 | 텍스트를 아무나 읽지 못하도록 인코딩하는 알고리즘 |
| --- | --- |
| 키 | 암호의 동작을 변경하는 숫자로 된 매개변수 |
| 대칭키 암호 체계 | 인코딩과 디코딩에 같은 키를 사용하는 알고리즘 |
| 비대칭키 암호 체계 | 인코딩과 디코딩에 다른 키를 사용하는 알고리즘 |
| 공개키 암호법 | 비밀 메시지를 전달하는 수백만대의 컴퓨터를 쉽게 만들 수 있느 시스템 |
| 디지털 서명 | 메시지가 위조 혹은 변조되지 않았음을 입증하는 체크섬 |
| 디지털 인증서 | 신뢰할 만한 조직에 의해 서명되고 검증된 신원 확인정보 |

## 14.2.1 비밀 코드의 기술과 과학

- 암호법(cryptography)은 메시지 인코딩과 디코딩에 대한 과학이자 기술(art)이다.
- 사람들은 수천 간 암호법의 방법론을 비밀 메시지를 보내는데 적용해왔다.
- 메시지를 암호화하는 것 뿐만 아니라, 메시지의 변조를 방지하기 위해 사용할 수 있다.
- 누군가 정말로 어떤 메시지나 트랜잭션의 저자임을 증명하는 데도 사용할 수 있다.

## 14.2.2 암호(cipher)

- 암호법은 암호라 불리는 비밀 코드에 기반한다. 암호란 메시지를 인코딩하는 어떤 특정한 방법과 나중에 그 비밀 메시지를 디코딩하는 방법이다.
- 인코딩 되기 전의 원본 메시지는 흔히 텍스트 혹은 평문이라고 불리며 암호가 적용되어 코딩된 메시지는 보통 암호문이라고 불린다.
- 율리우스 카이사르는 메시지의 각 극자를 해당 글자의 알파벳 순서상 세번 뒤의 글자로 교체하는 세글자 순환 암호를 사용했다.

## 14.2.3 암호 기계

- 암호는 상대적으로 간단한 알고리즘을 시작했는데 , 기술이 진보하면서, 사람들은 보다 복자반 암호로 메시지를 빠르고 정확하게 인코딩하고 디코딩 하는 기계를 만들기 시작했다. 글를 회전하고, 그 순서를 바꾸며 메시지를 토막 냈다.

## 14.2.4 키가 있는 암호

- 코드 알고리즘과 기계를 훔치더라도 올바른 다이얼 설정(키값)이 없이는 디코더가 동작하지 않을 수 있다.

## 14.2.5 디지털 암호

- 속도 및 기능에 대한 기계 장치의 한계에서 벗어남으로써 복잡한 인코딩과 디코딩 알고리즘이 가능해졌다.
- 매우 큰키를 지원하는 것이 가능해졌고,단일 암호 알고리즘으로 키의 값마다 다른 수조개의 가상 암호 알고리즘을 만들어낼 수 있다. 키가 길수록 인코딩의 많은 조합이 가능해지고 무작위로 추측한 키에 의한 크래킹이 어려워졌다.
- 디지털 키는 숫자에 불과하다. 이들 디지털 키 값은 인코딩과 디코딩 알고리즘에 대한 입력 값이다.
- 평문 메시지 P, 인코딩 함수 E, 디지털 인코딩 키 e가 주어지면 부호화된 암호문 C를 생성할 수 있다. 그리고 암호문 C를 디코더 함수 D와 디코딩 키 D를 사용해서 원래의 평문 P로 도로 디코딩할 수 있다.

## 14.3 대칭키 암호법

- 대칭키 암호화는 인코딩을 할 때 사용하는 키와 디코딩 할 때 와 같기 때문이다.
- 대칭키 암호에서 발송자와 수신자 모두 통신을 위해 비밀 키 k를 똑같이 공유할 필요가 있다.
- 발송자는 공유된 비밀키를 메시지를 암호화 하고 그 결과인 아호문을 수신자에게 발송하기 위해 사용한다. 수신자는 역시 암호문을 받은 뒤 같은 공유된 키를 사용하여 원래의 평문을 복원하기 위해 해독 함수를 적용한다.
- 유명 대칭키 알고리즘으로는 DES,Triple-Des,RC2,RC4등이 있다.

## 14.3.1 키 일와 열거 공격(Enumeration Attack)

- 무차별로 모든 키 값을 대입으로 모든 값을 시도하고 결국 암호를 깨게 될 것 입니다.
- 가능한 키 값의 개수는 키가 몇 비트이며 얼마나 많은 키가 유효한지에 달려있다.
- 평범한 대칭키는 40비트 키를 사용하지만 미국 정부에서는 긴 키를 사용하는 암호화 소프트웨어의 수출한다. 암호에 기반하고 보안에 있어 키의 길이 는 중요하다.

## 14.3.2 공유키 발급하기

- 대칭키 암호의 단점 중하나는 발송자와 수신ㅈ가 서로 대화하려면 둘다 공유키를 가져야한다는 것이다.
- 대화 참여자가 각 쌍은 그들만의 개인키를 가질 필요가 있다. 만약 N개의 노드가 있고 , 각 노드가 상대 N-1과 은밀하게 대화를 나누어야 한다면, 대략 총 $N^2$개의 비밀키가 필요하다.

## 14.4 공개키 암호법

- 인코딩 하는 키는 공개 되어 있고 디코딩하는 키는 호스트만 알고 있다.
- 메시지의 인코딩은 누구나 할 수 있도록 해주는 동시에 , 메시지를 디코딩하는 능력은 소유자에게만 부여한다. 이는 노드가 서버로 안전하게 메시지를 발송하는 것을 더 쉽게 해주는데 왜냐하면 서버의 공개키만 있으면 되기 때문이다.
- 공개키 암호화 기술은 보안 프로토콜은 전 세계의 모든 컴퓨터 사용자에게 적용하는 것을 가능하게 했다. 표준화된 공개키 기술 묶음을 만드는 것의 중요성 때문에 거대한 공개키 인프라(public-key infrastructure,PKI)표준화 작업이 25년 넘게 계속 진행중인 상태다.

### 14.4.1 RSA

- 아래의 조건을 알고있더라도 비밀 키를 계산할 수 없는 것을 확신시킬 수 있다.
    - 공개키
    - 가로채서 얻은 암호문의 일부
    - 메세지와 그것을 암호화한 암호문
- 이 모든 요구를 만족하는 공개키 암호 체계 중 유명한 하나는 MIT에서 발명 되고 이어서 RSA 데이터 시큐리티에서 사용화된 RSA 알고리즘이다.

### 14.4.2 혼성 암호 체계와 세션 키

- 비대칭 공개키 암호 방식은 누구나 공개키만 알면 그 키에 대응되는 공개 서버에 안전하게 메시지를 보낼 수 있게 해주므로 훌륭하다.
- 공개키 암호 방식은 알고리즘 계산이 느린 경향이 있다.
- 실제로는 대칭과 비대칭 방식을 섞은 것이 쓰인다.
    - 의사 소통 채널에는 공개키 암호를 사용하고 , 이렇게 만들어진 안전한 채널에 임시의 무작위 대칭키를 생성하고 교환하여 이후의 나머지 데이터를 암호화 할때는 빠른 대칭키를 사용하는 방식이 흔히 쓰인다

## 14.5 디지털 서명

- 암호체계는 암호화하고 해독하는 것뿐 아니라, 누가 메시지를 썻는지 알려주고 그 메시지가 위조되지 않았음을 증명하기 위해 메시지에 서명을 하도록 하는 데에 이용할 수 있다.

 

### 14.5.1 서명은 암호 체크섬이다

- 디지털 서명은 메시지에 붙어 있는 특별한 암호 체크섬이다.
    - 서명은 메시지를 작성한 저자가 누군지를 알려준다.저자는 저자의 극비 개인 키를 갖고 있기때문에 오직 저자만 이 체크섬을 계산할 수 있다. 체크섬은 저장의 개인 “서명”처럼 동작한다.
    - 서명은 메시지 위조를 방지한다.만약 악의적인 공격자가 송신중인 메시지를 수정했다면, 체크섬은 저자의 비밀 개인 키에 관련되어 있기 때문에, 침입자는 그 위조된 메시지에 대한 올바른 체크섬을 날조해낼 수 없을 것이다.
- 디지털 서명은 보통 비대칭 공개키에 의해 생성된다. 개인키는 오직 소유자만이 알고 있기 때문에, 저자의 개인 키는 일종의 ‘지문’처럼 사용된다.

## 14.6 디지털 인증서

- 디지털 인증서(certs)는 신뢰할 수 있는 기관으로부터 보증 받은 사용자나 회사에 대한 정보를 가지고 있다.

### 14.6.1 인증서의 내부

- 디지털 인증서에는 또한 공식적으로 ‘인증기관’에 의해 디지털 서명된 정보의 집합이 담겨있다.
- 기본적인 디지털 인증서는 아래와 같은 내용들을 담고 있다
    - 대상의 이름(사람,서버,조직)
    - 유효기간
    - 인증서 발급자
    - 인증서 발급자의 디지털 서명
- 디지털 인증서는 대상과 사용된 서명 알고리즘에 대한 서술적인 정보 뿐 아니라 보통 대상의 공개키도 담고 있다.
- 누구나 디지털 인증서를 만들 수 있지만, 그 모두가 인증서의 정보를 보증하고 인증서를 개인 키로 서명할 수 있는 널리 인정받는 서명 권한을 얻을 수 있는 것은 아니다.

### 14.6.2 x.509 v3 인증서

- 디지털 인증서에 대한 전 세계적인 단일 표준은 없다.
- 오늘날 사용되는 대부분의 인증서가 그 들의 정보를 x.509라 불리는 표준화된 서식에 저장하고 있다.

| 필드 | 설명 |
| --- | --- |
| 버전 | 이 인증서가 따르는 X.509 인증서 버전의 번호. 요즘은 보통 버전 3이다 |
| 일련번호 | 인증기관에 의해 생성된 고유한 정수. CA로부터의 각 인증서는 반드시 고유한 일련번호를 가져야 한다 |
| 서명 알고리즘 ID | 서명을 위해 사용된 암호 알고리즘. 예를 들면 'RSA 암호화를 이용한 MD2요약' |
| 인증서 발급자 | 인증서가 유효한 기간. 시작일과 종료일로 정의된다. |
| 대상의 이름 | 인증서에 기술된, 사람이나 조직과 같은 엔터티. 이 대상 이름은 X.500포맷으로 기록되어 있다 |
| 대상의 공개 키 정보 | 인증 대상의 공개 키. 공개 키에 사용된 알고리즘. 추가 매개변수 |
| 발급자의 고유 ID(선택적) | 발급자의 이름이 겹치는 경우를 대비한, 인증서 발급자에 대한 선택적인 고유한 식별자 |
| 대상의 교유ID(선택적) | 대상의 이름이 겹치는 경우를 대비한, 인증 대상에 선택적인 고유한 식별자 |
| 확장 | 선택적인 확장 필드의 집합. 
기본 제약 - 대상과 인증기관과의 관계
인증서 정책 - 인증서가 어떤 정책하에 승인되었는지
키 사용 - 공개키가 어떻게 사용될 수 있는지 |
| 인증기관 서명 | 위의 모든 필드에 대한 인증기관의 디지털 서명. 명시된 서명 알고리즘을 사용한다. |

### 14.6.3 서버 인증을 위해 인증서 사용하기

- 사용자가 HTTPS를 통한 안전한 웹 트랜잭션을 시작할 때, 최신 브라우저는 자동으로 접속한 서버에서 디지털 인증을 가져온다.
- 서버가 인증서를 갖고 있지 않다면, 보안 커넥셔은 실패한다.
- 서버 인증서는 아래와 같은 많은 필드를 갖고 있다.
    - 웹사이트의 이름과 호스트명
    - 웹사이트의 공개키
    - 서명기관의 이름
    - 서명 기관의 서명
- 브라우저가 인증서를 받으면 , 서명 기관을 검사한다.
- 만약 그기관이 공공이 신뢰할만한 서명 기관이라면 브라우저는 그것의 공캐키를 이미 알고 있을 것이다.
- 브라우저는 그 서명을 검증할 수 있다.

## 14.7 HTTPS의 세부사항

- HTTPS는 HTTP의 가장 유명한 보안 버전이다.
- HTTPS는 HTTP 프로토콜에 대칭, 비대칭 인증서 기반 암호 기법의 강력한 집합을 결합한 것이다.

## 14.7.1 HTTPS 개요

- HTTPS는 그냥 보안 전송 계층을 통해 전송되는 HTTP이다. 암호화되지 않은 HTTP메시지를 TP를 통해 전 세계의 인터넷 곳곳으로 보내는 대신에 HTTPS는 HTTP 메시지를 TCp로 보내기 전에 먼저 그것들을 암호화하는 보안 계층으로 보냅니다.
- 오늘날 HTTPS의 보안계층은 SSl과 그것의 현대적 대체품인 TLS로 구현되었다.
- 오늘날 우리는 SSL과 TLS 모두를 의미하는 단어로 “SSL”을 사용하는 관행을 따르는 것이다.

![Untitled](14%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%87%E1%85%A9%E1%84%8B%E1%85%A1%E1%86%AB%20HTTP%20a9bbfec559c141338752dce66ecef470/Untitled.png)

## 14.7.2 HTTPS 스킴

- 보안 HTTP는 선택적이다.
- 웹 서버로의 요청을 만들 때 , 우리는 웹 서버에게 HTTP의 보안 프로토콜 버전을 수행한다고 말해줄 방법이 필요하다. 이것은 URL의 스킴을 통해 이루어진다.

```html
보안이 없는 URL : http://www.joes-hardware.com/index.html (접두사 HTTP)
보안이 되는 URL : https://www.joes-hardware.com/index.html (접두사 HTTPS)

```

- HTTP 스킴을 갖고 있다면 클라이언트는 서버에 80번(기본값) 포트로 연결한다.
- HTTPS 스킴을 갖고 있다면 클라이언트는 서버에 443번(기본값)포트로 연결한다.

![Untitled](14%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%87%E1%85%A9%E1%84%8B%E1%85%A1%E1%86%AB%20HTTP%20a9bbfec559c141338752dce66ecef470/Untitled%201.png)

- SSL 트래픽은 바이너리 프로토콜이기 때문에 HTTP와는 완전히 다르다.
- 만약 SSL과 HTTP 트래픽 모두가 80포트로 도착한다면, 대부분의 웹브라저는 바이너리 SSL 트래픽을 잘못된 HTTP로 해석하고 커넥션을 닫을 것이다.
- 보안 서비스가 HTTP 쪽으로 좀 더 계층 통합이 되도록하면 포트가 둘 이상 필요할 이유가 사라지겠지만, 사실 심각한 문제를 일으키지는 않는다

### 14.7.3 보안 전송 셋업

- 암호화 되지 않은 HTTP에서 클라이언트는 웹 서버의 80번 포트로 TCP 커넥션을 열고, 요청 메시지를 보내고, 응답 메시지를 , 커넥션을 닫는다.
- HTTPS에서는 절차는 SSL보안 계층 때문에 약간더 복ㅈ바하다. HTTPS에서 클라이언트는 먼저 웹서버의 443포트(보안 HTTP의 기본 포트)로 연결한다. 일단 TCP 연결이 되고 나면, 클라이언트와 서버는 암호화 매개변수와 교환 키를 협상하면서 SSL 계층을 초기화한다. 핸드 셰이크가 완료되면 SSL 초기화는 완료되면, 클라이언트는 요청 메시지를 보안계층에 보낼 수있다.

![Untitled](14%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%87%E1%85%A9%E1%84%8B%E1%85%A1%E1%86%AB%20HTTP%20a9bbfec559c141338752dce66ecef470/Untitled%202.png)

### 14.7.4 SSL 핸드셰이크

- 핸드셰이크에서는 다음과 같은 일이 일어난다.
    - 프로토콜 버전 번호 교환
    - 양쪽이 알고 있는 암호 선택
    - 양쪽의 신원을 인증
    - 채널을 암호화 하기 위한 임시 세션 키 생성
    
    ![Untitled](14%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%87%E1%85%A9%E1%84%8B%E1%85%A1%E1%86%AB%20HTTP%20a9bbfec559c141338752dce66ecef470/Untitled%203.png)
    

### 14.7.5 서버 인증서

- SSL은 서버 인증서를 클라이언트로 나르고 다시 클라이언트 인증서를 서버로 날라주는 상호 인증을 지원한다. 하지만 요즘 잘 쓰이지 않는다.
- 웹 서버는 클라이언트 인증서를 요청할 수 있지만 실제로도 일어나지도 않고 사용자도 인증서를 가지고 있지 않다.(클라이언트 인증서 -> 보통 쓰지 않음)
- 보안 HTTPS 트랜잭션은 항상 서버 인증서를 요구한다.(서버 인증서 -> HTTPS에서 무조건 요구)

### 14.7.6 사이트 인증서 검사

- SSL 자체는 사용자에게 웹서버 인증서를 검증하지 않지만 최신 웹브라우저들 대부분 인증서에 대한 간단한 검사 및 더 철저한 검사를 할 수 있는 방법을 알려준다.
    - **날짜 검사** : 브러우저는 인증서가 여전히 유효함을 확인한다. 인증서의 시작 및 종료 일을 검사한다. 인증서가 만료 및 활성화가 안되었다면, 인증서 검사는 실패
    - **서명자 신뢰도 검사**
        - 모든 인증서는 서버를 보증하는 어떤 인증 기관에 의해 서명되어있다.
        - 인증서는 각각 다른 배경 검증을 요구한다.
        - 어떤 사이트 인증서에서 서명을 한다면, 브라우저는 그 인증서를 올바른 CA경로에서 파생된 것으로 보고 받아 들일 수 있다.
    - **서명 검사** : 한번 서명기관이 믿을 만하다고 판단하면, 브라우저는 서명기관의 공개키를 서명에 적용하여 그의 체크섬과 비교해봄으로써 인증서의 무결성을 검사한다.
    - **사이트 신원 검사** :인증서를 복사하거나 트래픽을 가로채는 것을 방지하기 위해 브라우저는 인증서의 도메인 이름이 대화중인 서버의 도메인 이름과 비교하여 맞는지 검사합니다.
        - 서버 인증서에는 보통 단일 도ㅁ인 이름이 들어있지만 몇몇 CA는 서버 클러스터나 서버 팜을 위해 서버 이름의 목록이나 서버 이름들에 대한 와일드 카드 표현이 들어있는 인증서를 만든다.
        - 만약 호스트명이 인증서의 신원과 맞지 않는다면, 사용자를 우선으로 생각하는 클라이언트 반드시 이사실을 사용자에게 알리거나 잘못된 인증서 에러와 함께 커넥션을 끊어야한다.

### 14.7.7 가상 호스팅과 인증서

- 사용자가 인증서의 이름과 정확히 맞지 않는 가상 호스트명에 도착했다면 경고 상자가 나타날것이다.
- 이런 문제를 피하기 위해 웹사이트는 보안 트랜잭션을 시작한 모든 사용자를 서버 인증서에 있는 호스트 명으로 리다이렉트한다.

## 14.8 진짜 HTTPS 클라이언트

- SSL은 복잡한 바이너리 프로토콜이다. 독자가 암호전문가가 아닌 이상 가공지 않은 SSL 트래을 직접 보내지 마라

### 14.8.1 OpenSSL

- OpenSSL은 SSL과 TLS의 가장 인기 있는 오픈 소스 구현이다. OpenSSL 프로젝트는 강력한 다목적 암호법 라이브러리인 동시에 SSL과 TLS 프로토콜을 구현한 강건하고 완전한 기능을 갖춘 사용 수준의 툴킷을 개발하고자 한 자원봉사자들이 협업한 결과물이다.
- https://[www.openssl.org](http://www.openssl.org/)

### 

## 14.9 프락시 를 통한 보안 트래픽 터널

- 클라이언트는 종종 그들을 대신하여 웹 서버에 접근해주는 웹 프락시 서버를 이용한다.
- 클라이언트가 서버의 공개키로 암호화 하기 시작했다면, 프락시는 더 이상 HTTP 헤더를 읽을 수 없다. 프락시는 어디로 요청을 어디로 보내야할지 알 수 없다.
- HTTPS와 프락시와도 잘 동작할 수 있게 하기 위해 클라이언트가 프락시에게 어떠한 접속하려고 하는지 말해주는 방법을 약간 수정하는데 제일 인기 있는 기법하나가 HTTPS SSL 터널링 프로토콜이다.
- HTTP는 CONNECT라 불리는 새로운 확장 메서드를 이용해서 평문으로 된 종단 정보를 전송하기 위해 사용된다.
- CONNECT 메서드는 프락시에게 희망하는 호스트와 포트번호로 연결을 해달라고 말해주며 그ㄳ이 완료되면, 클라이언트와 서버 사이에서 데이터가 직접적으로 오갈 수 있게 터널을 만든다.

![Untitled](14%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%87%E1%85%A9%E1%84%8B%E1%85%A1%E1%86%AB%20HTTP%20a9bbfec559c141338752dce66ecef470/Untitled%204.png)

![Untitled](14%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%87%E1%85%A9%E1%84%8B%E1%85%A1%E1%86%AB%20HTTP%20a9bbfec559c141338752dce66ecef470/Untitled%205.png)