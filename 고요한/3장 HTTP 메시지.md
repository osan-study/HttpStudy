# HTTP 메시지

HTTP가 인터넷의 배달원이라면, HTTP 메시지는 무언가를 담아 보내는 소포와 같다.

### 3.1 메시지의 흐름

- HTTP 메시지는 HTTP 애플리케이션 간에 주고 받은 데이터의 블록들이다. 이 데이터의 블록들은 메시지의 내용과 의미를 설명하는 텍스트 메타 정보로 시작하고 그 다음에 선택적으로 데이터가 올 수 있다.
- 이 메시지는 클라이언트,서버,프락시 사이를 흐른다.
- “**인바운드**”,”**아웃바운드**”,”**업스트림**”,”**다운 스트림**”은 메시지의 방향을 의미하는 용어이다.

### 3.1.1 메시지는 원 서버 방향을 인바운드로 하여 송신된다.

- 클라이언트에서 서버 방향으로 데이터가 가는 것은 **인 바운드**
- 서버에서 클라이언트로 데이터를 보내는 것을 **아웃 바운드**라고 한다.

### 3.1.2 다운 스트림으로 흐르는 메시지

- 요청 메시지 혹은 응답 메시지 관계없이 모든 메시지는 **다운 스트림** 으로 흐른다.
- 메시지의 발송자는 수신자의 **업 스트림**이다.

### 3.2 메시지의 각 부분

- 메시지는 시작줄,헤더 블록, 본문 세 부분으로 이루어져 있다.
- **시작줄** : 어떤 메시지인지에 대한 서술
- **헤더 블록** : 속성
- **본문** : 데이터를 담고 있다. 본문은 아예 없을 수도 있다.

### 3.2.1 메시지 문법

- 모든 HTTP 메시지는 **요청 메시지**나 **응답 메시지**로 분류된다.
- CRLF는 간단히 말해 줄바꿈(newline)을 입력하는 문자를 칭하는 표현입니다

요청 메시지

![Untitled](HTTP%20%E1%84%86%E1%85%A6%E1%84%89%E1%85%B5%E1%84%8C%E1%85%B5%207a14dbb16472472295d6c4d78c4f5622/Untitled.png)

```sql
GET /doc/test.html HTTP/1.0
Host : www.test101.com

bokid=12345...

**<메서드> <요청 URL> <버전>
헤더 
데이터 본문**
```

응답 메시지

![Untitled](HTTP%20%E1%84%86%E1%85%A6%E1%84%89%E1%85%B5%E1%84%8C%E1%85%B5%207a14dbb16472472295d6c4d78c4f5622/Untitled%201.png)

```sql
GET /doc/test.html HTTP/1.0
Host : www.test101.com

bokid=12345...

**<버전> <요청 URL> <버전>
헤더 
데이터 본문**
```

**메서드**

- 클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작
- ‘HEAD’ , POST 와 같이 한 단어로 되어있다.

**요청 URL**

- 요청 대상이 되는 리소스를 지정하는 완전한 URL 혹은 URL의 경로 구성요소이다.

**버전**

- 메시지에서 사용 중 인 HTTP 버전이다. 메이저와 마이너는 모두 정수다.

```html
HTTP/<메이저>.<마이너>
```

**상태 코드**

- 요청 중에 무엇이 일어났는지 설명하는 세 자리의 숫자다.

**사유 구절**

- 숫자로 된 상태 코드의 의미를 사람이 이해할 수있게 설명해주는 짦은 문구로 , 상태 코드 이후로 부터 줄 바꿈 문자열까지 사유 구절이 된다.
- 사유구절은 오로지 사람에게 읽히기 위한 목적으로 존재 하는 구절이다.
- “HTTP/1.0 200 NOT OK”와 “HTTP/1.0 200 OK”는 사유 구절이 서로 전혀 달라 보임에도 불구 하고 동등하게 성공을 의미하는 것으로 처리된다 ? NOT OK와 OK가 같은 의미인지 모르겠음

**헤더들**

- 이름,콜론: 선택적인 공백, 값 , CRLF가 순서대로 나타는 0개 이상의 헤더들. 이 헤더의 목록은 빈줄(CRLF)로 끝나 헤더 목록의 끝과 엔터티 본문의 시작을 표시한다. HTTP/1.1과 같은 몇 버전의 HTTP는 요청이나 응답에 어떤 특정 헤더가 포함 되어야만 유효한 것으로 간주된다.

**엔터티 본문**

- 엔터티 본문은 임의의 데이터 블록을 포함한다. 모든 메시지가 엔터티 본문을 갖는것은 아니므로, 때때로 메시지는 그냥 CRLF으로 끝나게 한다.
- 헤더나 엔터티 본문이 없더라도 HTTP 헤더의 집합은 항상 빈줄(그냥 CRLF)로 끝나야 함에 주의하라.
- 클라이언트와 서버는 마지막 CRLF 없이 끝나는 메시지도 받아들일 수 있어야 함

### 3.2.2 시작줄

- 모든 HTTP 메시지는 시작 줄로 시작한다. 요청 메시지의 시작줄 은 무엇을 해야 하는지 말해준다.

 **요청줄**

- 요청 메시지는 서버에게 리소스 에 대해 무언가를 해 달라고 부탁한다.
- 요청 메시지의 시작줄, 혹은 요청줄에는 서버에서 어떤 동작이 일어나야 하는지 설명해주는 메서드와 그 동작에 대한 대상을 지칭하는 요청 URL 이 들어 있다.
- 이 모든 필드는 공백으로 구분된다.

**응답줄**

- 응답 메시지는 수행 결과에 대한 상태 정보와 결과 데이터를 클라이언트에게 돌려준다.
- 응답 메시지의 시작줄 혹은 응답줄에는 응답메시지에 쓰인 HTTP의 버전, 숫자로 된 상태코드,수행 상태에 대한 설명해주는 텍스트로 된 사유 구절이 들어있다.
- 이 모든 필드는 공백으로 구분된다.

**메서드**

- 요청의 시작줄은 메서드로 시작하며, 서버에게 무엇을 해야 하는지 말해준다.
- HTTP 명세는 공통 요청 메서드의 집합을 정의한다.

| 메서드 | 설명 | 메시지 본문이 있는가? |
| --- | --- | --- |
| GET | 서버에서 어떤 문서를 가져온다 | 없음 |
| HEAD | 서버에서 어떤 문서에 대해 헤더만 가져온다. | 없음 |
| POST | 서버가 처리해야 할  데이터를 보낸다. | 있음 |
| PUT | 서버에 요청 메시지의 본문을 저장한다. | 있음 |
| TRACE | 메시지가 프락시 거쳐 서버에 도달하는 과정을 추적한다. | 없음 |
| OPTIONS | 서버가 어떤 메서드를 수행할 수 있는지 확인한다. | 없음 |
| DELETE | 서버에 문서를 제거한다. | 없음 |
- 모든 서버가 위와 같이 메서드를 모두 구현한 것은 아니라는 점에 주의하라.

**상태코드**

- 상태코드는 클라이언트에게 무엇이 일어났는지 말해준다.
- 상태코드는 각 응답 메시지의 시작줄에 담겨 반환된다.
- 사유구절이 사람에게 쉽게 읽히는 한편, 숫자로 된 코드는 프로그램이 에러를 처리하기 쉽다.

| 전체 범위 | 정의된 범위 | 분류 |
| --- | --- | --- |
| 100-199 | 100-101 | 정보 |
| 200-299 | 200-206 | 성공 |
| 300-399 | 300-305 | 리다이렉션 |
| 400-499 | 400-415 | 클라이언트 에러 |
| 500-599 | 500-505 | 서버 에러 |

**사유구절**

- 마지막 구성요소이다. 이것은 상태코드에 대한 글 로된 설명을 제공한다.
- “HTTP/1.0 200 OK”라는 줄에서 , 사유 구절은 OK이다.
- 상태 코드의 사람이 이해하기 쉬운 버전이다.

**버전번호**

- 버전 번호는 HTTP/x.y 형식으로 요청과 응답 메시지 양쪽 모두에 기술된다.
- HTTP 애플리케이션들이 자신이 따르는 프로토콜의 버전을 상대방에게 말해주기 위한 수단이다.
- HTTP 버전이 다를 경우 그 기능을 사용할 수 없다.

### 3.2.3 헤더

- HTTP 헤더 필드는 요청과 응답 메시지에 추가 정보를 더한다. 그즐은 기본적으로 이름/값 쌍의 목록이다. 예를들어 , 다음의 헤더줄은 Content-Lenth 헤더 필드에 19라는 값을 할당한다.

```html
Content-length:19
```

**헤더 분류**

- HTTP 헤더 명세는 여러 헤더 필드를 정의한다. 애플리케이션은 또한 자유롭게 자신만의 헤더를 만들어 낼 수 있다.

**일반 헤더**

- 요청과 응답 양쪽에 모두 나타낼 수 있음

**요청 헤더**

- 요청에 대한 부가 정보를 제공

**응답 헤더**

- 응답에 대한 부가 정보를 제공

**Entity 헤더**

- 본문 크기와 콘텐츠 , 혹은 리소스 그 자체를  서술

**확장 헤더**

- 명세에 정의 되지 않은 새로운 헤더

| 헤더의 예 | 설명 |
| --- | --- |
| Date : tue , 3 Oct m1997 02 : 16:03 GMT | 서버가 응답을 만들어 낸 시각 |
| Content-length : 15040 | 15,040바이트의 데이터를 포함한 엔터티 본문 |
| Content - Type : image/gif | 엔터티 본문은 GIF 이미지다. |
| Accept : image/gif,image/jpeg,text/html | 클라이언트는 GIF,JPEG 이미지와 HTML을 받아 들일 수 있다. |

**헤더를 여러 줄로 나누기**

- 긴 헤더 줄은 여러줄로 쪼개서 더 읽기 좋게 만들 수 있다. 추가줄 앞에 최소하나의 스페이스 혹은 탭 문자가 와야한다.

```
HTTP/1.0 200 OK
Content-Type : image/gif
Content-Length : 8971
Server : Test Server
    Version 1.0
```

### 3.2.4 엔터티 본문

- HTTP 메시지의 세번째부분은 선택적인 엔터티 본문이다. 엔터티 본문은 HTTP 메시지의 화물이라고 한다.그것들은 HTTP가 수송하도록 설계된 것들이다.
- HTTP 메시지는 이미지,비디오 , HTML 문서, 소프트웨어 애플리케이션, 신용카드 트랜잭션,전자우편등 여러 종류의 디지털 데이터를 실어 나를 수 있다.

### 3.3.1 안전한 메서드(Safe Method)

- 서버에 어떤 영향을 주지 않는 메서드 이다. 결과로 서버에 어떠한 작용도 없음을 의미한다.

### 3.3.2 GET 메서드

- 서버에게 리소스를 달라고 요청하기 위해 쓰인다.

### 3.3.3 HEAD 메서드

- GET처럼 행동하지만 헤더값만 돌려준다.
- 리소스를 가져오지 않고도 그에 대한 무엇인가를 알 수 있다.
- 응답의 상태 코드를 통해 개체가 존재하는지 확인할 수 있다.
- 헤더를 확인하여 리소스가 변경 되었는지 검사할 수 있다.

### 3.3.4 PUT

- 서버에 문서를 작성한다.
- 어떤 발행 시스템은 사용자가 PUT을 이요해 웹페이지를 만들고 웹서버에 직접 게시할 수 있도록 한다.
- 새 문서를 작성하거나 본문을 교체하는 용도로 쓰인다.

### 3.3.5 POST

- 입력 데이터를 전송하기 위해 설계 되었다.
- 데이터를 보내기 위해 사용한다.
- 로그인,회원 가입등에 많이 사용된다.

### 3.3.6 TRACE

- 클라이언트에게 자신의 요청이 서버에 도달 했을 때 어떻게 보이게 되는지 요청한다.
- TRACE 메서드는 주로 진단을 위해 사용한다.
- TRACE 요청은 어떠한 엔터티 본문도 보낼 수 없다. TRACE 응답의 엔터티 본문에는 서버가 받은 요청이 그대로 들어있다.

### 3.3.7 OPTIONS

- 웹 서버에게 여러가지 종류의 지원 범위에 대해 물어본다.
- 서버에게 특정 리소스에 대해 어떤 메소드가 지원되는지 물어볼 수 있다.
- OPTIONS 요청이 모든 리소스에 대한 것이므로, 서버는 자신의 리소스에 대해 지원하는 메서드의 목록을 반환한다.

### 3.3.8 DELETE

- 서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청한다.

### 3.3.9 확장 메서드

- HTTP는 필요에 따라 확장해도 문제가 없도록 설계 되어있으므로 새로운 기능을 추가해도 과거에 구현된 소프트웨어들의 오동작을 유발하지 않는다.
- 모든 확장 메서드가 형식을 갖춘 명세로 정의된것은 아니라는 점에서 주의해야한다.
- 확장 메서드를 다룬 때는 “엄격하게 보내고 관대하게 받아들여라”라는 규칙이 있다.

| 메서드 | 설명 |
| --- | --- |
| LOCK | 사용자가 리소스를 잠글 수 있게 해준다. 예를 들어 문서를 편집하는 동안 다른 사람이 동시에 같은 문서를 편집하지 못하도록 문서를 잠금할 수 있다. |
| MKCOL | 사용자가 문서를 생성할 수 있게 핸준다. |
| COPY | 서버에 있는 리소스를 복사한다. |
| MOVE | 서버에 있는 리소스를 옮긴다. |

### 3.4 상태 코드

- 상태코드는 클라이언트에게 그들의 트랜잭션을 이해 할 수 있는 쉬운 방법을 제공한다.

### 3.4.1 100-199 : 정보성 상태코드

- 정보성 상태 코드는 HTTP/1.1에서 도입 되었다.

### 3.4.2 200-299 : 성공 상태 코드

- 클라이언트가 요청을 보내면, 그 요청은 대개 성공한다.
- 서버는 대응하는 성공을 의미하는 상태 코드의 배열을 갖고 있으며, 각각 다른 종류의 요청에 대응한다.

### 3.4.3 300-399 : 리다이렉션 상태 코드

- 클라이언트가 관심있어하는 리소스에 대해 다른위치를 사용하라고 말해주거나 그 리소스의 내용 대신 다른 대안 응답을 제공한다.

### 3.4.4 400-499 : 클라이언트 에러 상태 코드

- 잘못 구성된 요청메시지 같은 것이 있을 수 있다. 가장 흔한것은 존재하지 않는 URL을 요청하는 것이다.
- 많은 클라이언트 에러가 당신을 귀찮게 하지 않고 브라우저에서 처리된다.

### 3.4.5 500-599 : 서버 에러 상태 코드

- 서버 자체에서 에러가 발생할 수 있다. 이것은 클라이언트가 서버의 제한에 걸린 것 일 수도 있고 혹은 게이트웨이 리소스와 같은 서버의 보조 구성 요소에서 발생한 에러를 표시하는 코드이다.

### 3.5 헤더

- 헤더와 메서드는 클라이언트와 서버가 무엇을 하는지 결정하기 위해 함께 사용된다.\

**일반헤더**

- 클라이언트와 서버 양쪽 모두가 사용한다. 이들은 클라이언트 , 서버 그리고 어딘가에 메시지를 보내는 다른 애플리케이션들을 위해 다양한 목적으로 사용된다.

**응답헤더**

- 응답하는 메시지는 클라이언트에게 정보를 제공하기 위한 자신만의 헤더를 갖고 있다.

**엔터티 헤더**

- 본문에 대한 헤더를 만한다. 예를 들어 헤더를 엔터티 본문에 들어있는 데이터 타입의 무엇인지를 말해 줄 수 있다.

**확장헤더**

- 애플리케이션 개발자들에 의해 만들어졌으며 아직 승인되 HTTP 명세에는 추가 되지않은 비표준 헤더이다.
- HTTP 프로그램은 확장 헤더들에 대해 설령 그 의미를 모른다 할지라도 용인하고 전달해야한다.