# 11장 클라이언트 식별과 쿠키

- 웹 서버는 서로 다른 수천 개의 클라이언트들과 동시에 통신한다.
- 서버와 통신하고 있는 클라이언트를 추적해야 할 수 도 있다.

## 11.1 개별 접촉

- HTTP는 익명 이며 상태가 없고 요청과 응답을 가지고 있는 통신 프로토콜이다.
- 서버는 클라이언트가 보낸 요청을 처리하고 나서 그 응답을 클라이언트로 전송한다.
- 현대의 웹 사이트들은 개인화 된 서비스를 제공하고 싶어 한다.

**개별인사**

- 개인에게 맞춰져 있는 것처럼 느끼게 하려고 사용자에게 특화된 환영 메시지나 페이지 내용을 만든다.
- 구글 및 네이버 등  내 생일을 알려주거나 결혼 기념일을 챙겨주는 경우

**사용자 맞춤 추천**

- 고객의 생일이나 기념일이 다가오면 특별한 제품을 제시하기도 한다.

**저장된 사용자 정보**

- 온라인 쇼핑에서 고객의 주소를 저장하여 사용 있게 한다.

**세션 추적**

- HTTP 트랜잭션은 상태가 없다. 각 요청 및 응답은 독립적으로 일어난다.
- 많은 웹사이트에서 사용자가 사이트와 상호작용할 수 있게 사용자의 상태를 남긴다.
- 웹 사이트는 각 사용자에게서 오는 HTTP 트랜잭션을 식별할 방법이 필요하다.
    - 사용자 식별 관련 정보를 전달하는 HTTP 헤더들
    - 클라이언트 Ip 주소 추적으로 알아낸 IP주소로 사용자를 식별
    - 사용자 로그인 인증을 통한 사용자 식별
    - URL에 식별자를 포함하는 기술인 뚱뚱한(Fat) URL

## 11.2 HTTP 헤더

| 헤더이름 | 헤더 타입 | 설명 | 추가 설명 |
| --- | --- | --- | --- |
| From | 요청 | 사용자의 이메일 주소 | 스팸 메일 발송으로 인한 from을 요청 하는 헤더는 많지 않음 |
| User-Agent | 요청 | 사용자의 브라우저 정보 | 브라우저의 정보를 서버에 알려준다. |
| Referer | 요청 | 사용자가 형재 링크를 타고 온 근원 페이지 | 현재 페이지로 유입하게 한 웹페이지의 URL |
| Authorization | 요청 | 사용자 이름과 비밀번호 |  |
| Client-ip | 확장(요청) | 클라이언트의 IP주소 |  |
| X-Forwarded-For | 확장(요청) | 클라이언트의 IP주소 |  |
| Cookie | 확장(요청) | 서버가 생성한 ID 라벨 |  |

## 11.3 클라이언트 IP 주소

- 클라이언트 Ip주소로 사용자를 식별하는 방식은 다음과 같은 약점을 가지고 있다.
    - 하나의 컴퓨터에 여러 클라이언트들이 사용한다면 IP주소로 식별할 수 없다.
    - 인터넷 서비스 제공자(ISP)는 사용자가 로그인하면 동적으로 IP주소를 할당한다.
    - 사용자가 네트워크 주소 변환(NAT) 방화벽을 통해 인터넷을 사용한다.
    - 웹서버는 클라이언트의 IP 주소 대신 프락시 서버의 IP주소를 본다. 일부 프락시는 원본 IP 주소를 본다. 일부 프락시는 원본 IP 주소를 보존하려고 Client-Ip나 X-Forwarded-For HTTP 같은 확장 헤더를 추가하여 이 문제를 해결 하려고 했다. 하지만 모든 프락시가 이런 식으로 동작하지 않는다.

## 11.4 사용자 로그인

- IP 주소로 사용자를 식별하려는 수동적인 방식보다, 웹 서버는 사용자 이름과 비밀번호 인증(로그인)할 것을 요구해서 사용자에게 명시적으로 식별 요청을 할 수 있다.
- 웹 사이트 로그인이 더 쉽도록 HTTP는 WWW-Authenticate(인증)와 Authorization(허가)헤더를 사용해 웹 사이트에 사용자 이름을 전달하는 자체적인 체계를 가지고 있다.
- 한번 로그인 하면, 브라우저는 사이트로 보내는 모든 요청에 이 로그인 정보를 함께 보내므로 웹 서버는 그 로그인을 시키고자 한다면 HTTP 401 Login Required 응답 코드를 브라우저에 보낼 수 있다.(**401 Code** : 요청된 리소스에 대한 유효한 인증 자격 증명이 없기 때문에 클라이언트 요청이 완료되지 않았음을 나타냅니다.)

## 11.5 뚱뚱한 URL

- URL은 URL 경로의 처음이나 끝에 어떤 상태 정보를 추가해 확장한다.
- 사용자가 그 사이트를 돌아다니면, 웹서버는 URL에 있는 상태 정보를 유지하는 하이퍼 링크를 동적으로 생성한다.
- 사용자가 상태 정보를 포함하고 있는 URL을 뚱뚱한 URL이라고 한다.

**못생긴 URL**

- 브라우저에 보이는 뚱뚱한 URL은 새로운 사용자들에게 혼란을 준다.

**공유하지 못하는 URL**

- 뚱뚱한 URL은 사용자의 상태 정보를 포함한다. 만약 그 주소를 공유하면 개인정보를 공유하는 것이다.

**캐시를 이용할 수 없음**

- URL로 만드는 것은 URL이 달라지기 때문에 기존 캐시에 접근할 수 없다.

**서버 부하 가중**

- 서버는 뚱뚱한 URL에 해당하는 HTML 페이지를 다시 그려야한다.

**이탈**

- 특정 URL을 요청해서 의도치 않게 뚱뚱한 URL 세션에서 “이탈”하기 쉽다.
- 사용자가 이탈하게 되면 사용하는 링크는 초기화되서 다시 처음부터 시작해야 한다.

**세션 간 지속성의 부재**

- 사용자가 특정 뚱뚱한 URL을 북마킹하지 않는 이상, 로그아웃하면 모든 정보를 잃는다.

## 11.6 쿠키

- 쿠키는 사용자를 식별하고 세션을 유지하는 방식중에서 현재까지 가장 널리 사용하는 방식이다.
- 쿠키는 넷스케이프가 최초로 개발했고 현재는 모든 브라우저에서 지원한다.
- 쿠키는 캐시와 충돌할 수 있어서 ,대부분 캐시나 브라우저는 쿠키에 있는 내용물을 캐싱하지 않는다.

### 11.6.1 쿠키의 타입

- 쿠키는 크게 세션 쿠키(session cookie)와 지속 쿠키(persistent cookie) 두가지 타입으로 나눌 수 있다.
- 세션쿠키와 지속쿠키의 다른점은 파기되는 시점 뿐이다.
- **세션 쿠키(session cookie)**
    - 사용자가 사이트를 탐색할 때, 관련한 설정과 선호 사항들을 저장하는 임시 쿠키다.
    - 세션 쿠키는 사용자가 브라우저를 닫으면 삭제된다.
- **지속 쿠키(persistent cookie)**
    - 디스크에 저장되어, 브라우저를 닫거나 컴퓨터를 재시작하더라도 남아있다.
    - 지속 쿠키는 사용자가 주기적으로 방문하는 사이트에 대한 설정 정보나 로그인 이름을 유지하려고 사용한다.

### 11.6.2 쿠키는 어떻게 동작하는가

- 웹서버는 사용자가 첫 방문하면 사용자에 대해서 아무것도 모른다 하지만 웹 서버는 사용자가 다시 돌아왔을 때, 해당 사용자를 식별할  유일한 값을 쿠기에 할당한다.
- 쿠키는 임의의 이름 = 값 형태의 리스트를 가지고 , 그 리스트는 Set-Cookie 혹은 Set-Cookie(확장헤더)같은 HTTP 응답헤더에 기술되어 사용자에게 전달한다.
- 쿠키는 어떤 정보든 포함할 수 있다. 하지만 서버가 사용자 추적용도로 생성한 유일한 다순 식별 번호만 포함하기도 한다.
- 서버는 쿠키 값으로 데이터베이스서 사용자의 정보(구매 내용,주소 정보)를 찾는데 사용할 수 있다.

### 11.6.3 쿠키 상자 : 클라이언트 측 상태

- 쿠키의 기본적인 발상은 브라우저가 서버 관련 정보를 저장하고 , 사용자가 해당 서버에 접근할때 그 정보를 함께 전송하게 하는 하는 것이다.
- 브라우저는 쿠키 정보를 저장할 때 책임이 있는데, 이 시스템을 ‘클라이언트 측 상태’라고 한다.
- 쿠키 명세에서 이것의 공식적인 이름은 “HTTP 상태 관리 체계(HTTP State Management Mechanism)”이다.
- **크로미움 쿠키**
    - Cookies라는 Sqllite 파일에 쿠키를 저장한다.
    
    | 쿠키 필드 | 내용 |
    | --- | --- |
    | creation_utc | 쿠키의 생성 시점 |
    | host_key | 쿠키의 도메인 |
    | name | 쿠키의 이름 |
    | value | 쿠키값 |
    | path | 쿠키의 관련된 도메인 경로 |
    | expire_utc | 쿠키의 파기 시점 |
    | secure | 쿠키를 SSL 커넥션일 경우에만 보낼지를 가리킨다. |
- **인터넷 익스플로러 쿠키**
    - 캐시 디렉터리에 각각의 개별 파일로 쿠키를 저장한다.
    - 파일에 있는 각 쿠키의 첫번 째 줄은 쿠키의 이름이다.
    - 두번째줄은 쿠키의 값
    - 세번째 줄은 쿠키의 이름

### 11.6.4 사이트마다 각기 다른 쿠키들

- 브라우저는 보통 각 사이트에 두개 혹은 세개의 쿠키만을 보낸다.
    - 쿠키를 모두 전달하면 성능이 저하 된다.
    - 쿠키는 서버에 특화된 이름/값 쌍을 포함하고 있기 때문에 대부분 사이트에서 인식하지 않는 무의미한 값이다.
    - 특정 사이트에서 제공한 정보를 신뢰하지 않는 사이트에 가져갈 수 있고 잠재적인 개인정보문제를 일으킬 것이다.
- 브라우저는 쿠키를 생성한 서버에게만 쿠키에 담긴 정보를 전달한다.
- 많은 웹사이트는 광고를 관리하는 협력 업체와 계약을 한다.
    - 이 광고들은 웹사이트 자체의 일부인 것 처럼 제작 되며 지속 쿠키를 만들어 낸다.
    - 같은 광고사에서 제공하는 서로 다른 웹 사이트에서 사용자가 방문하면, 브라우저는 앞서 만든 지속 쿠키를 다시 광고사 서버에 전송한다. 이는 지속 쿠키의 도메인이 같기 때문이다.
    - 광고사는 이 기술에 Referer 헤더를 접목하여 사용자의 프로필과 웹사이트를 사용하는 습관에 대한 방대한 데이터를 구축할 수 있다.
    - 브라우저들은 개인정보 설정 기능을 통해 협력 업체의 쿠키 사용 방식에 제약을 가할 수도 있다.
- **쿠키 Domain 속성**
    - 서버는 쿠키를 생성할 때 Set-Cookie 응답 헤더에 Domain 속성을 기술해서 어떤 사이트가 그 쿠키를 읽을 수 있는지 제어할 수 있다.
    - HTTP 응답 헤더는 브라우저가 user=”mary17”이라는 쿠키를 .test.com 도메인을 가지고 잇는 모든 사이트에 전달한다는 의미다.
    
    ```csharp
    Set-cookie : user="mary17"; domain="test.com"
    ```
    
    - 만약 사용자가 [www.test.com](http://www.test.com)  혹은 a.test.com으로 끝나는 사이트를 방문하면 다음 cookie헤더가 항상 적용될 것이다.
- **쿠키 Path 속성**
    - 웹 사이트는 일부에만 쿠키를 적용 할 수도 있다.
    - URL 경로의 앞 부분을 가리키는 Path 속성을 기술해서 해당 경로에 속하는 페이지에만 쿠키를 전달한다.
    - 쿠키는 일종의 상태 정보라고 할 수 있으며, 서버가 생성하여 클라이언트에 전달하고, 클라이언트는 그 쿠키를 유효한 사이트에만 다시 전달하고 관린 한다.

### 11.6.5 쿠키 구성 요소

- 쿠키 명세에는 Version0 , Version 1쿠키가 있다. Version1쿠키는 Version 0 쿠키의 확장으로 널리 쓰이지는 않는다.
- Version 0 쿠키 명세와 Version1 쿠키 명세 모두 Http/1.1 명세 일부로 기술되어 있지는 않다.

### 11.6.6 Version 0(넷스케이프) 쿠기

- 최초의 쿠키는 명세는 넷스케이프가 정의했다.
- “Version 0” 쿠키는 Set-Cookie 응답 헤더와 Cookie 요청 헤더와 쿠키를 조작하는데 필요한 필드들을 정의했다.

```html
Set-cookie: name=value [; expires=date] [; path=path] [; domain=domain] [; secure]
Cookie: name1=value1 [; name2=value]
```

- Version 0 Set-Cookie 헤더

| 속성 | 필수 | 설명 |
| --- | --- | --- |
| 이름=값 | 필수 | 세미콜론, 쉼표, 등호, 공백은 포함할 수 없다 (단, 큰따옴표로 감싸면 가능)
ex. Set-Cookie: user=Woobin |
| Expires | 선택 | 쿠키 만료 시각 (GMT 타임존만 사용 가능)
ex. Set-Cookie: user=Woobin; expires=Wednesday, 09-Feb-20 23:12:40 GMT |
| Domain | 선택 | 서버가 특정 도메인에만 쿠키를 제한적으로 전달하게 한다.두 개에서 세 개 영역을 가지는 도메인을 기술해야 한다. (.com, .edu 같은 것만으로는 안됨)Set-Coookie: user=Woobin; domain="google.com" |
| Path | 선택 | 서버에 있는 특정 문서에만 쿠키를 할당할 수 있다.
Set-Cookie: user=Woobin; path=/orders |
| Secure | 선택 | 이 속성이 포함되어 있으면 SSL 보안 연결을 사용할 때만 쿠키를 전송한다.
Set-Cookie: user=Woobin; secure |

### 11.6.7 Version 1(RFC 2965) 쿠키

- Version1 표준은 Set-Cookie2와 Cookie2 헤더를 소개하고 있으며 Version 0 시스템과도 호환된다.
- RFC 2965쿠키는 표준은 원 버전이 넷스케이프 표준보다 좀 더 복잡하며, 아직 모든 브라우저나 서버에 완전히 지원하지 않는다.
- **변경사항**
    - 쿠키마다 목적을 설명하는 설명문이 있다.
    - 만료 주기와 상관없이 브라우저가 닫힐 때 쿠키를 삭제할 수 있다.
    - 절대 날짜(Expires) 대신 초 단위의 상대 값(Max-age)으로 쿠키의 생명주기를 결정한다.
    - 포트 번호로도 쿠키를 제어한다.
    - 버전 번호가 추가되었다.
    - Cookie 헤더에 $ 접두어가 있다.
    - (서버) Version 1 Set-Cookie2 헤더

### 11.6.8 쿠키와 세션 추적

- 쿠키는 웹사이트에 수차례 트랜잭션을 만들어내는 사용자를 추적하는데 사용한다.
- 전자상거래 웹 사이트는 사용자가 온라인 쇼핑을 하는 중에 그들의 쇼핑카트를 유지하려 세션쿠키를 사용한다.

![Untitled](11%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%8F%E1%85%B3%E1%86%AF%E1%84%85%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8B%E1%85%A5%E1%86%AB%E1%84%90%E1%85%B3%20%E1%84%89%E1%85%B5%E1%86%A8%E1%84%87%E1%85%A7%E1%86%AF%E1%84%80%E1%85%AA%20%E1%84%8F%E1%85%AE%E1%84%8F%E1%85%B5%203ca4c167b8f346f6ad94fad57216598c/Untitled.png)

### 11.6.9 쿠키와 캐싱

- 쿠키 트랜잭션과 관련된 문서를 캐싱하는 것을 주의해야한다. 이전 사용자의 쿠키가 다른 사용자에게 할당 돼버리거나 누군가의 개인정보가 다른 이에게 노출되는 최악의 상황이 일어날 수 있다.
- **캐시되지 말아야 할 문서가 있다면 표시하라**
    - 문서를 캐시하면 될지 안 될지는 문서의 소유자가 가장 잘 안다.
    - 문서가 Set-Cookie헤더를 제외하고 캐시를 해도 될 경우라면 그 문서에 명시적으로 Cache-Control:no-cache=”Set-Cookie”를 기술해서 명확히 표시한다.
    - 캐시를 해도 되는 문서에 Cache-Control : public을 사용하면 웹의 대역폭을 더 절약 시켜준다.
- **Set-Cookie 헤더를 캐시 하는 것에 유의하라**
    - 만약 응답이 Set-COokie헤더를 가지고 있으면, 본문은 캐시할 수 있지만. Set-Cookie 헤더를 캐시하는 것은 주의를 기울여야만 한다.같은 Set-Cookie헤더를 여러 사용자에게 보내게 되면, 사용자 추적에 실패할 것이기 때문이다.
    - 어떤 캐시는 응답을 저장하기전에 Set-Cookie 헤더를 제거하기 때문에 , 그 캐시데이터를 바는 클라이언트는 Set-Cookie헤더 정보가 없는 데이터를 받게 되어 문제가 발생할 수 있다. 캐시가 모든 요청마다 원 서버와 재검사시켜 클라이언트로 가능 응답에 Set0Cookie 헤더 값을 기술해서 이 문제를 개선할 수 있다.
- **Cookie 헤더를 가지고 있는 요청을 주의하라**
    - 요청이 Cookie 헤더와 함께 오면, 결과 콘텐트가 개인정보를 담고 있을 수도 있다는 힌트다.
    - 개인정보는 캐시되지 앟도록 표시되어있어야 하지만, 그 표시를 하지 않는 서버도 있다.
    - 보수적인 캐시는 Cookie 헤더가 포함된 요청에 응답으로 오는 문서는 캐시하지 않을 것이다.(Set-Cookie가 있는 이미지에 대해서는 캐시를하지만 Set-Cooie가 있는 텍스트는 캐시를 하지 않는 캐시도 있다.)
    - 캐시 이미지에 파기 시간인 0인 Cookie헤더를 설정해 매번 재검사를 하도록하는 것이다.

### 11.6.10 쿠키, 보안 그리고 개인 정보

- 쿠키를 사용하지 않도록 비활성화 시킬 수도 있고 , 로그 분석과 같은 방법으로 대체하는 것도 가능하다(보안상 엄청 문제될 위험은 아니다).
- 원격 데이터베이스에 개인정보를 저장하고 해당 데이터의 키 값을 쿠키에 저장하는 방식을 표준으로 사용하면, 클라이언트와 서버 사이에 예민한 데이터 오가는 것을 줄일 수 있다.
- 제공하는 개인정보를 누가 받는지 명확히 알고 사이트에 ㄱ인정보 정책에만 유의한다면, 쿠키에 관련한 위험성 보다 세션 조작이나 트랜잭션상의 편리함이 크다.