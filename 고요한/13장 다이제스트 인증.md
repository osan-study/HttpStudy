# 13장 다이제스트 인증

- 기본인증은 편리하고 유연하지만 전혀 안전하지 않다.
- 다이제스트 인증은 기본 인증과 호환되는 더 안전한 대체제로 개발되었다.
- 다이제스트 인증은 널리 쓰이지 않지만 그 개념은 보안 트랜잭션을 구현하고자 하는 이들에게 여전히 유용하다.

## 13.1 다이제스트 인증의 개선점

- 다이제스트 인증은 기본 인증의 가장 심각한 결함을 수정한 또다른 HTTP인증 프로토콜이다.
    - 비밀번호를 절대로 네트워크를 통해 평문으로 전송하지 않는다.
    - 인증 체결을 가로채서 재현하려는 악의적인 사람들을 차단한다.
    - 구현하기에 따라서, 메시지 내용 위조를 막는 것도 가능하다.
    - 그 외 몇몇 잘 알려진 형태의 공격을 막는다.
- 다이제스트 인증이 가장 안전한 프로토콜은 아니다.
- 요구사항들에게는 전송 계층 보안(TLS)과 HTTP가 더 적합한 프로토콜이다.
- 기본인증보다 훨씬 강력하고 인기 있는 보안 체계들 보다 더 강력하다.

### 13.1.1 비밀번호를 안전하게 지키기 위해 요약 사용하기

- 다이제스트는 “절대로 비밀번호를 네트워크를 통해 보내지 않는다”이다.
- 클라이언트는 비밀번호를 비가역적 뒤섞은 “지문”혹은 “요약”을 보낸다.
- 서버는 클라이언트가 보낸 요약이 비밀번호에 알맞게 대응하는지 검사할 수 있다.

### 13.1.2 단방향 요약

- 정보 본문의 압축이다. 암호화는 단방향 함수로 동작하고, 일반적으로 입력 가능한 무한가지의 모든 입력 값들은 유한한 범위의 압축으로 변환한다.
- MD5는 임의의 바이트 배열을 원래 길이와 상관없이 128비트 요약으로 변환한다.
- 이 요약에서 중요한 것은 , 만약 비밀번호를 모른다면 서버에게 보내줄 알맞은 요약을 추측하기 위해 끔찍하게 많은 시간을 소모하게 될 것이라는 점이다. 그리고 마찬가지로, 요약을 갖고 있다면 거의 무한개의 입력 값 들중 그 요약을 생성하는 것을 찾기 위해 끔찍하게 많은 시간을 소모하게 될것이다.
- 암호화는 보통 암호 체크섬으로 불리며, 단방향 해시 함수이거나 지문 함수 이다.

### 13.1.3 재전송 방지를 위한 난스(nonce)사용

- 재전송 공격을 방지하기 위해서 서버는 클라이언트에게 난스라고 불리는 특별한, 그리고 자주 바뀌는 증표를 건네 준다.
- 난스를 비밀번호에 섞으면 난스가 바뀔 때마다 요약도 바뀌게 만들어준다. 이것은 재 전송 공격을 막아주는데 왜냐 하면 저장된 비밀번호 요약은 특정 난스값에대해서만 유효하고, 비밀번호 없이 공격자가 올바른 요약을 계산하는 것을 가능하지 않기 때문이다.
- 다이제스트 인증은 난스를 사용할 것을 요구하는데 그 이유는 자잘한 재전송 공격들이 난스를 쓰지 않는 다이제스트 인증을 실질적으로 기본 인증만크 허약한 것으로 만들기 때문이다.
- 난스는 암호화 토큰입니다. **난스(nonce), 랜덤 생성 토큰**

 

### 13.1.4 다이제스트 인증 핸드셰이크

1. 서버가 난스를 생성한다.(난스 값을 계산한다)
2. 서버는 난스를 WWW-Authenticate 인증요구 메시지에 담아, 서버가 지원하는 알고리즘 목록과 함께 클라이언트에게 전송한다.
3. 알고리즘을 선택하고 응답 요약을 생성한다.
4. 클라이언트가 요약을 담아서 서버에게 돌려준다. 만약 클라이언트가 서버 인증을 원한다면 클라이언트 난스를 생성하여 함께 보낼 수도 있다.
5. 서버는 클라이언트가 했던 그대로 요약을 계산한 다음 자신이 계산한 요약과 네트워크로 전송되어 온 요약이 일치하는지 확인한다. 만약에 클라이언트가 대칭적으로 서버에게 클라이언트 난스를 가지고 인증을 요구했다면, 클라이언트 요약이 만들어진다.

## 13.2 요약 계산

- 다이제스트 인증의 핵심은 공개된 정보,비밀정보,시한부 난스값을 조합한 단방향 요약입니다.

### 13.2.1 요약 알고리즘 입력 데이터

- 단방향 해시 함수 H(d)와 요약 함수 KD(s,d). 여기서 s는 비밀(secert)을,d는 데이터를 의미한다.
- 비밀번호 등 보안 정보를 담고 있는 데이터 덩어리 A1이라 칭한다.
- 요청메시지의 비밀이 아닌 속성을 담고 있는 데이터 덩어리.A2라 칭한다.

A1,A2 두 조각의 데이터는 요약을 생성하기 위해 H와 KD에 의해 처리된다.

### 13.2.2 H(d)와 KD(s,d) 알고리즘

- 다이제스트 인증은 여러가지  요약 알고림즘을 선택할 수 있도록 지원한다.
- RFC 2617에서 제안된 두 알고리즘은 MD5와 MD5-sess(’sess’는 세션을 뜻한다)이며, 만약 알고리즘이 정해지지 않았다며 MD5가 기본값이다.
- MD5와 MD5-sess 중 어느 것이 사용되더라도, H함수는 데이터의 MD5를 계산하고, KD 요약함수는 콜론으로 연결된 비밀 데이터와 일반 데이터의 MD5를 계산한다.

```html
H(<데이터>) = MD5(<데이터>)
KD(<비밀>,<데이터>) = H(연결<비밀>:<데이터>))
```

### 13.2.3 보안 관련 데이터(A1)

- A1으로 불리는 데이터 덩어리는 사용자 이름,비밀번호,보호영역,난스와 같은 비밀번호 정보로 이루어져있다.
- A1은 메시지 자체가 아닌 비밀 정보와만 관련되어있다.
- MD5 : 모든 요청마다 단 방향 해시를 실행한다. A1은 사용자 이름 , 영역, 비밀번호를 콜론으로 연결한다.
- MD5-sess : 사용자 이름 , 영역,비밀번호에 대한 해시를 계산한 결과 뒤에 현재 난스와 클라이언트 난스(cskstm)를 붙인 것이 A1이 된다. CPU를 많이 사용하는 해시 계산은 처음 WWW-Authenticate 핸드 셰이크를 할대 단 한번만 수행한다.

| 알고리즘 | A1 |
| --- | --- |
| MD5 | A1=<사용자>:<영역>:<비밀번호> |
| MD5-sess | A1=MD5(<사용자>:<영역>:<비밀번호>):<난스>:<c난스> |

### 13.2.4 메시지 관련 데이터 (A2)

- A2로 불리는 데이터 덩어리는 URL,요청 메서드, 메시지 엔터티 본문과 같은 메시지 자체의 정보를 나타낸다.
- A2는 메서드 , 리소스, 메시지의 위조를 방지하기 위해 사용된다. A2는 H,KD,A1과 마찬가지로 요약을 계산하기 위해 사용된다.
- RFC 2617은 선택 된 보호 수준(Quality of Protection,qop)에 따른 A2의 두가지 사용법을 정의하고 있다.
    - 첫번째 방법은 HTTP 요청 메서드와 URL만 포함하는 것이다. 이것이 기본값이기도 한 QOP=”auth”일대 사용한다.
    - 두 번째 방법은 메시지 무결성 검사를 제공하기 위해 메시지 엔터티 본문을 추가하는 것이다. 이것은 qop=”auth-int”일 때 사용된다.
    
    | qop | A2 |
    | --- | --- |
    | 정의 되지 않음 | <요청메서드> :<uri 지시자의 값> |
    | auth | <요청메서드> :<uri 지시자의 값> |
    | auth-int | <요청메서드> :<uri 지시자의 값> : H(<요청 엔터티 본문>) |
- 요청 메서드는 HTTP 요청 메서드다.
- uri 지시자 값은 요청줄에서 가져온 요청 URI이다.
- 이것은 ‘*’,’absouluteURL’,’abs_path’중 아무것이나 될 수 있지만 반드시 요청 URL와 일치해야한다.
- 요청 URI가 absouluteURL이라면 uri지시자 값도 반드시 absoluteURL이어야 한다.

### 13.2.5 요약 알고리즘 전반

- RFC2617은 주어진 H,KD,A1,A2로 요약을 계산하는 두가지 방법을 정의한다.
    - 첫번째 방법은 예전 명세인 RFC2069와 호환을 염두에 둔것으로 QOP옵션이 빠졋을때 사용된다. 비밀 정보와 난스가 붙은 메시지 데이터의 해시를 이용해 요약을 계산한다.
    - 두번째 방법은 현대적이면서 보다 선호되는 접근법으로 난스 횟수 집계 및 대칭인중의 지원을 포함한다. 이 접근법은 QOP가 ‘auth’일 때와 ‘auth-int’일때 모두 사용된다. 이것은 난스횟수 ,qop,c난스 데이터를 요약에 추가한다.

| qop | 요약 알고리즘 | 비고 |
| --- | --- | --- |
| 정의되지 않음 | KD(H(A1),<난스>:H2(A2)) | 없어질 예정이다. |
| auth  혹은 auth-int | KD(H(A1),<난스>:<nc>:<c난스>:<qop>:H(a2)) | 이 방법이 선호된다. |
- 식을 짧게 하기위해 지나치게 압축된 알고리즘은 이해가 어려울 수 있다.

| qop | 알고리즘 | 펼쳐진 알고리즘 |
| --- | --- | --- |
| 정의되지 않음 | <정의되지 않음>
MD5
MD5-sess | MD5(MD5(A1):<난스>:MD5(A2)) |
| auth | <정의되지 않음>
MD5
MD5-sess | MD5(MD5(A1):<난스>:<nc>:<난스>:<qop>:MD5(A2)) |
| auth_int | <정의되지 않음>
MD5
MD5-sess | MD5(MD5(A1):<난스>:<nc>:<난스>:<qop>:MD5(A2)) |

### 13.2.6 다이제스트 인증 세션

- 클라이언튼느 사용자이름 , 비밀번호, 난스, 난스 횟수, 그리고 보호공간 내 미래의 요청에 들어갈 Authorization 헤더를 만들기 위해 사용될  인증 세션과 연관된 알아보기 힘든 값들을 기억해야한다.
- 난스가 만료되면 서버는 포함한 난스 값이 낡을 것일 수 있음을 감수하고 오래된 Auuthorization 헤더 정보를 받아들이는 것을 택할 수 있다. 아니면, 서버는 클라이언트가 다시 요청을 보내도록 새 난스값과 함께 401응답을 반환할 수도 있다. 이 응답에 “stale=true”로 정의함으로써 서버는 클라이언트에게 사용자 이름과 비밀번호를 새로 입력 되도록 창을 띄울 필요없이 새 난스값으로 요청을 다시 보내라고 말할 수 있다.

### 13.2.7 사전(preemptive)인가

- 사전인가는 기본인증에서 사소하고 흔한 것 이다.브라우전는 흔히 사용자 이름고 비밀번호 들에 대한 클라이언트 측 데이터베이스를 관리한다. 사용자가 어떤 사이트에 한번 인증을 하면, 브라우저는 흔히 그 URL에 대한 다음번 요청때 올바른 Authorization 헤더를 전송한다.
- 다이제스트 인증에서의 사전 인가는 약간 더 복잡한데, 왜냐하면 난스 기술을 재전송 공격을 저지하기 위한 것이기 때문이다. 서버는 임의의 난스를 생성하기 때문에 인증요구를 받기 전에 클라이언트가 무엇이 바른 Authoriation 헤더인지 알 방법이 없다.
- 다이제스트 인증은 여러가지 안전한 기능을 유지하면서 사전 인가를 할 수 있는 몇가지 방법을제안한다.
    - 서버가 다음 난스를 Authentication-Info 성공 헤더를 담아 미리 보낸다.
    - 서버가 짧은 시간 동안 같은 난스를 재사용하는 것을 허용한다.
    - 클라이언트와 서버가 동기화되어 있고 예측 가능한 난스 생성 알고리즘을 사용한다.

**다음 난스 미리 생성하기**

- 서버는 Authentication-Info 성공 헤더를 통해 다음 난스 값을 미리 제공할 수 있다.
- 서버는 인증이 성공했을때 200OK 응답과 함께 이 헤더를 미리 보낸다.

```html
Authentication-Info : nextnonce ='<난스 값>'
```

**제한된 난스 재사용**

- 난스를 재사용하면 공격자의 재 전송 공격이 성공하기 쉬워지므로 보안성이 감소 된다.
- 난스 재사용의 수명은 절대 재사용안함  부터 잠재적으로 오랫동안 재사용까지 통제 가능하기 때문에 취약점과 성능간의 트레이드 오프가 있을 수 있다.

**동기화된 난스 생성**

- 제 3자가 쉽게 예측할 수 없는 공유된 비밀키에 기반하면서 클라이언트와 서버가 순차적으로 같은 난스를 생성할 수 있도록 시간적으로 동기화된 난스 생성알고리즘을 사용하는 것도 가능하다.

### 13.2.8 난스 선택

- RFC 2617에서 다음과 같은 가상의 난스 공식을 제안했다.

```html
BASE64(타임 스탬프 H(타임스탬프":" ETag " : " 개인키))
```

- 타임 스태프는 서버에서 생성된 시간 혹은 아무것이나 불가능한 값이면 디고, ETag는 요청된 엔터티에 대한 ETag헤더값이며, 개인 키는 서버만이 알고 있는 값이다.
- Etag를 포함하면 갱신된 리소스에 대한 재 요청을 방지한다(클라이언트의 IP 주소를 난스에 포함하는 것은, 서버에게 같은 클라이언트가 원래 받았던  난스에 포함하는 것은, 서버에게 같은 클라이어트가 원래 받았던 난스를 재사용하는 것에 제한 하는 능력을 주는 것처럼 보일 수도 있다. 그러나 한사용자가 여러 프락시를 거쳐 요청할수 있기 때문에 , 이는 프락시 팜(proxy-farms)을 망가 뜨리게 될 수도 있을것이다. 또 한 Ip주소를 속이는 것은 그다지 어렵지 않다.)
- 재전송 공격을 방지하기 위해, 어떤 구현은 이전에 사용된난스나 요약을 받아들이지 않도록 결정할 수 있다. 혹은 post나 put요청을 위해 일회성 난스나 요약을 사용하고, GET 요청을 위해 타임스탬플를 사용할 수 있다.

### 13.2.9 상호인증

- RFC 2617은 클라이언트가 서버 인증할 수 있도록 다이제스트 인증을 확장했다.
- 서버가 공유된 비밀 정보에 근거한 올바른 응답요약을 생성할 수 있도록, 클라이언트 난스(c난스)값을 제공함으로써 가능해진다.
- RFC2617로 표준화 되었다.. RFC 2069와의 하의 호환성을 고려해서 선택사항으로 남겨두긴했지만, 보안이 상당히 개서되므로 현대적인 클라이언트와 웹서버라면 반드시 구현할것을 권한다.
- 상호인증은 qop지시자가 존재할때는 항상 수행하여야 하고, 없다면 항숭 수행하지 말아야한다.
- 응답 요약은 메시지 본문정보(A2)가 다르다것만 제외하면 요청요약과 같은 방법으로 계산할 수 있다. 메시지 본문정보(A2)가 다른 이유는 응답에는 HTTP메서드라는 것이 없고 요청과 응답의 메시지 엔터티 데이터가 서로 다르기 때문이다.

| qop | A2 |
| --- | --- |
| 정의되지 않음 | <요청 메서드>: <uri 지시자 값> |
| auth | <요청 메서드>: <uri 지시자 값> |
| auth-int | <요청 메서드>:<URI 지시자값>:H(<요청 엔터티 본문>) |

| qop | A2 |
| --- | --- |
| 정의되지 않음 | <요청 메서드>: <uri 지시자 값> |
| auth | <요청 메서드>: <uri 지시자 값> |
| auth-int | <요청 메서드>:<URI 지시자값>:H(<응답 엔터티 본문>) |
- c난스값과 nc 값은 반드시 이 응답에 대응하는 클라이언트 요청을 위한 것이어야 한다.
- qop=”quth”나 qop=”quth-int”가 지정된 경우에는 반드시 응답 auth,c난스,난스 횟수 지시자가 존재해야한다.

## 13.3 보호수준(Quality of Protection) 향상

- qop 필드는 요약 헤더의 세가지 헤더 WWW_Authenticate , Authorization,Authentciation-Info에 모두 존재할 수 있다.
- qop 필드는 클라이언트와 서버가 어떤 보호 기법을 어느 정도 수준으로 사용할 것인지 협상할 수 있게 해준다.
- 서버는 우선 WWW-Authenticate 헤더에 qop 옵션을 쉼표로

### 13.3.1 메시지 무결성 보호

- 무결성 보호가 적용되었을 때 계산되는 H(엔터티 본문)는 메시지 본문의 헤시가 아닌 엔터티 본문의 해시
- 송신자에 의해 먼저 계산되고 수신자에 의해 제거

### 13.3.2 다이제스트 인증 헤더

- 다이제스트 인증 프로토콜 양쪽모두 WWW-Authenticate 헤더에 담겨 전달되는 인증요구와 ,Authorization 헤더에 담겨 전달되는 인가 응답을 포함한다.
- 다이제스트 인증은 여기에 선택적인 Authentication-Info 헤더를 추가한다. 이헤더는 3단계 핸드셰이크를 완성하고 다음번 사용할 난스를 전달하기 위해 인증 성공 후에 전송된다.

![Untitled](13%E1%84%8C%E1%85%A1%E1%86%BC%20%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%8C%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%20%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%8C%E1%85%B3%E1%86%BC%20edbc7f86de574b7c91bd812723fe9b5f/Untitled.png)

## 13.4 실제 상황에 대한 고려

### 13.4.1 다중 인증요구

- 서버는 한 리소스에 대해 여러 인증을 요구할 수 있다.
- 서버는 기본 인증을 제한적으로만 사용해야 할 것이며, 관리자는 사용자에게 보안 수준이 다른 여러 시스템에서 같은 비밀번호를 사용하는 것의 위험성에 대해 경고해야 할 것이다.
- 클라이언트는 반드시 지원 가능한 가장 강력한 인증 메커니즘을 선택해야 함

### 13.4.2 오류 처리

- 요청의 요약이 맞지 않으면, 로그인이 실패했음을 기록해 두는 것이 좋다. 반복된 실패는 공격자가 비밀번호 추측을 시도하고 있음을 의미한다.
- 인증 서버는 반드시 ‘uri’ 지시자가 가리키는 리소스가 요청줄에 명시된 리소스와 같음을 확인해야하고 만약 다르다며 서버는 400Bad Request에러를 반화하는 것이 좋다.
- 이 필드와 요청 URL 과의 중복된 정보는 중간의 프락시가 클라이언트의 요청줄을 변조 가능성에 대처하고 변형된 요청의 요약을 계산한 결과는 클라이언트 계산한 요약과 다를 것이다.

### 13.4.3 보호공간(Protection Space)

- 영역값은 접근한 서버의 루트 URL 과 결합되어 보호공간을 정의한다.
- 영역은 서버의 보호된 리소스들을 자신만의 인증제도와 인가 데이터베이스 어느 한쪽 혹은 양쪽 모두를 가진 보호 영역의 집합으로 분할 할 수 있도록 해준다.영역값은 일반적으로 원서버에 의해 할당 되는 문자열이며 인증 제도에 추가적인 의미를 더한다. 인가 제도 같지만 영역은 다른 다중 인증 요구가 있을 수 있음에 주의 하라
- 보호공간은 어떤 자격이 자동으로 적용되는 영역으로 결정한다.
- 보인증 제도에 별달리 정의된 것이 없다면 하나의 보호공간은 서버 밖으로 확장 될 수 있다.
    - 기본이증에서 클라이언트는 요청 URI와 그 하위 의 모든 경로는 같은 보호공간에 있는것으로 가정한다.
    - 다이제스트인증에서, WWW-Authenticate: domain 필드로 보호 공간을 보다 엄밀하게 정의한다.

### 13.4.4 URI 다시 쓰기

- 프락시는 가리키는 리소스의 변경없이 구문만 고쳐서 URI를 다시 쓰기도 한다.
    - 호스트명은 정규화 되거나 IP주소로 대체될 수 있다.
    - 문자들은 “%” escape 형식으로 대체 될 수 있다.
    - 특정 원서버로 부터 가져오는 리소스에 영향을 주지 않는 타입에 대한 추가 속성이 URI의 끝에 붙거나 중간에 삽이 될 수 있다.
- 프락시가 URI를 변경할 수 있는 동시에 다이제스트 인증은 URI 값의 무결성을 검사하므로 다이제스트 인증은 이러한 변경에 의해 실패할 수 있다.

 

### 13.4.5 캐시

- 어떤 공유 캐시가 Authorization 헤더를 포함한 요청과 그에 대한 응답을 받을 경우 , 다음의 두 Cache-Control 지시자 중 하나가 응답에 존재하지 않는 한 다른 요청에 대해 그 응답을 반환해서는 안된다.
    - 만약 원서버의 응답이 “must-revalidate” Cache-Control 지시자를 포함한경우 캐시는 그 응답의 엔터티를 다음 요청에 대해 응답을 위해 활용 될 것 이다. 원서버가 새 요청을 인증할 수 있도록 우선 그 요청의 헤더를 이용해서 재 검사를 수행해야한다.
    - 만약 원서버의 응답이 “public” Cache-Control 지시자를 포함한 경우 , 응답 엔터니는 그 다음에 오는 임의의 요청에 대한 응답으로 반환 될 수 있다.

## 13.5 보안에 대한 고려사항

- RFC 2617은  HTTP 인증 제도에 내재된 보안위협의 일부를 정ㄹ리하는 존경스러운일을 했다.

### 13.5.1 헤더 부당 변경

- 헤더 부당 변경에 대해 항상 안전한 시스템을 제공하기 위해서 , 양 종단 암호화나 헤더에 대한 디지털 서명이 필요할 것이다.
- 다이제스트 인증은 쉽게 조작할 수 없는 인증 제도를 제공하는 것에 초점을 맞추고 있으나 반드시 그 보호를 데이터에까지 확장하는 것은 아니다. 보호수준에 대한 정보는 WWW-Authenticate와 Authorization 헤더에만 담겨있다.

### 13.5.2 재전송 공격

- 재전송 공격을 완전히 피할 수 있는 한 방법은 매 트랜잭션마다 유일한 난스 값을 사용하는 것이다.
- 이 구현에는 매 트랜재션 마다 서버는 유일한 난스를 타임아웃과 함께 발급한다.
- 발급된 난스 값은 그때의 트랜재셕과 주어진 타임아웃 값의 기간동안만 유효하다. 이 계산이 서버에 부하를 가중시킬수도 있다. 그러나 사소한 수준이다.

### 13.5.3 다중 인증 메커니즘

- 클라이언트가 언제나 가능한 한 가장 강력한 인증제도를 선택하도록 한다.
- • 위의 방법이 현실적으로 불가능하다면 가장 강력한 인증 제도만을 유지하는 프락시 서버를 사용하자. (사내 네트워크같이 모든 클라이언트가 우리가 선택한 강력한 인증제도를 지원할 수 있다고 알려진 경우에만 사용)

### 13.5.4 사전(dictionary)공격

- 사전공격은 전형적인 비밀번호 추측 공격이다.
- 크래킹 하기 어렵도록 상대적으로 복잡한 비밀번호를 사용하는것과 괜찮은 비밀번호 만료 정책 외에는 실직적으로 없다.

### 13.5.5 악의적인 프락시와 중간자 공격(Man-in-the-Middle Attack)

- 사용자에게 인증의 강도를 시각적으로 보여주는것, 클라이언트가 언제나 가능한 한 가장 강력한 인증을 선택하도록 설정하는 것등이다. 클라이언트는 여전히 도청에 취약하다. 이런 공격을 방어할 방법은 SSL을 사용하는 것이다.

### 13.5.6 선택 평문 공격

- 응답을 계산하기 위해 알려진 키를 사용하는 것은 응답의 암호 해독을 쉽게한다. 이것은 선택 평문 공격이라고 한다.
- **미리 계산된 사전 공격**
    - 먼저 공격 서버는 미리 결정된 난스와 자주 쓰이는 비밀번호들로 응답의 집합을 생성하고 사전을 만든다.
    - 난스를 클라이언트에게 전송 후 대응되는 응답을 받았다면 특정 사용자의 비밀번호를 얻은 것
- **자동화된 무차별 대입공격**
    - 많은 컴퓨터를 동원해 주어진 범위에서 가능한 모든 비밀번호를 열거
    - 클라이언트가 c난스 지시자를 사용하여 응답을 생성하게 하여 방어한다.

### 13.5.7 비밀번호 저장

- 다이제스트 인증 메커니즘은 사용자 응답을 서버 내부에 저장된 것(보통 사용자,이름,영역,비밀번호의 요약을 통해 계산되 H(A1)r과 사용자 이름의 투플)과 비교한다.
    - 비밀번호 파일이 평문으로 된 비밀번호를 포함하고 있다고 생각하고 안전하게 보호한다.
    - 영역 이름이 유일함을 보장하며, 비밀번호 파일이 유출되더라도 피해를 특정영역으로 국소화 한다. 호스트와 도메인을 포함한 완전한 영역 이름은 이 요구를 만족한다.
- 진정한 보안 트랜잭션은 오로지 SSL을 통해서만 가능하다.